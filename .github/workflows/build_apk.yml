# Compile Kiwi Browser
name: automatic build of apk

# Controls when the action will run. Triggers the workflow on push or pull request events
on:
  push:
    paths-ignore:
      - '*.md'
    branches: [ master ]
  pull_request:
    paths-ignore:
      - '*.md'
    branches: [ master ]

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:

  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: macos-latest
    
    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      - name: Installing osxfuse
        run: brew cask install osxfuse

    # Docker doesn't support MacOS natively, so we have to workaround it.
    #
    # First, using "docker-machine", we create a VM with xhyve as hypervisor.
    # This VM runs a Linux-derived OS called Boot2docker.
    #
    # Within this Boot2docker VM, we can spawn other OS (such as our Ubuntu Linux).
    # We spawn one Linux (Ubuntu) instance using the "docker" command that remotely controls the agent within Boot2docker.
    #
      - name: Installing docker
        run: brew install docker docker-compose docker-machine xhyve docker-machine-driver-xhyve
        
      - name: Setting up docker
        run: |
          sudo chown root:wheel $(brew --prefix)/opt/docker-machine-driver-xhyve/bin/docker-machine-driver-xhyve
          sudo chmod u+s $(brew --prefix)/opt/docker-machine-driver-xhyve/bin/docker-machine-driver-xhyve  
          mkdir -p ~/.docker/machine/cache
          curl -Lo ~/.docker/machine/cache/boot2docker.iso https://github.com/boot2docker/boot2docker/releases/download/v19.03.5/boot2docker.iso

      - name: Booting machine
        run: for i in $(seq 1 10); do docker-machine create --driver xhyve --xhyve-rawdisk --xhyve-cpu-count -1 --xhyve-memory-size 9000 --xhyve-disk-size '100000' default && s=0 && break || sudo kill -9 `ps aux | grep xhyve | grep -v grep | awk '{print $2}'` && sudo rm -rf /Users/runner/.docker/machine/machines/default && s=$? && sleep 15; done; (exit $s)    # Retry 10 times before abort
          
      - name: Exporting docker environment variables
        run: |
          DOCKER_TLS_VERIFY="$(docker-machine env default | grep DOCKER_TLS_VERIFY | sed -e 's/.*="//g' -e 's/"$//g')"
          DOCKER_HOST="$(docker-machine env default | grep DOCKER_HOST | sed -e 's/.*="//g' -e 's/"$//g')"
          DOCKER_CERT_PATH="$(docker-machine env default | grep DOCKER_CERT_PATH | sed -e 's/.*="//g' -e 's/"$//g')"
          DOCKER_MACHINE_NAME="$(docker-machine env default | grep DOCKER_MACHINE_NAME | sed -e 's/.*="//g' -e 's/"$//g')"
          DOCKER_IP="$(docker-machine ip default)";
          echo ::set-env name=DOCKER_TLS_VERIFY::${DOCKER_TLS_VERIFY}
          echo ::set-env name=DOCKER_HOST::${DOCKER_HOST}
          echo ::set-env name=DOCKER_CERT_PATH::${DOCKER_CERT_PATH}
          echo ::set-env name=DOCKER_MACHINE_NAME::${DOCKER_MACHINE_NAME}
          echo ::set-env name=DOCKER_IP::${DOCKER_IP}
          
      - name: Starting Ubuntu machine
        run: docker run --name ubuntu -t -d ubuntu:bionic

      # Everything below happens inside the Ubuntu inside Docker
      # All commands must be prefixed with docker exec
      # We use /root as working directory

      - name: Checking available disk-space
        run: docker exec -w /root ubuntu df -h

      - name: Installing git inside virtual environment (and lsb_release)
        run: |
          docker exec -w /root ubuntu apt-get update
          docker exec -w /root ubuntu apt-get install -y git lsb-core sudo
          
      - name: Installing tzdata
        run: docker exec -w /root ubuntu bash -c "DEBIAN_FRONTEND=noninteractive apt-get install -y tzdata"

      - name: Checking-out source-code
        run: docker exec -w /root ubuntu bash -c "git clone --single-branch --depth 1 https://github.com/kiwibrowser/src"

      - name: Checking-out CIPD dependencies
        run: docker exec -w /root ubuntu bash -c "git clone --single-branch --depth 1 https://github.com/kiwibrowser/dependencies .cipd"

      - name: Copying .gclient and .gclient_entries
        run: |
          docker exec -w /root ubuntu bash -c "cp .cipd/.gclient ."
          docker exec -w /root ubuntu bash -c "cp .cipd/.gclient_entries ."

      - name: Installing Python and OpenJDK
        run: docker exec -w /root ubuntu bash -c "apt-get install -y python openjdk-8-jdk-headless libncurses5"

      - name: Setting-up Java 8 as default Java provider
        run: docker exec -w /root ubuntu bash -c "update-java-alternatives --set java-1.8.0-openjdk-amd64"

      - name: Installing system dependencies
        run: |
          docker exec -w /root/src ubuntu bash -c "bash install-build-deps.sh --no-chromeos-fonts"
          docker exec -w /root/src ubuntu bash -c "build/linux/sysroot_scripts/install-sysroot.py --arch=i386"
          docker exec -w /root/src ubuntu bash -c "build/linux/sysroot_scripts/install-sysroot.py --arch=amd64"

      - name: Creating output folder
        run: docker exec -w /root ubuntu bash -c "mkdir -p src/out/android_arm"

      - name: Copying args.gn to target folder
        run: docker exec -w /root ubuntu bash -c "cp src/.build/android_arm/args.gn src/out/android_arm/"

      - name: Generating one-time APK signature key
        run: docker exec -w /root ubuntu bash -c "keytool -genkey -v -keystore keystore.jks -alias dev -keyalg RSA -keysize 2048 -validity 10000 -storepass public_password -keypass public_password -dname 'cn=Kiwi Browser (unverified), ou=Actions, o=Kiwi Browser, c=GitHub'"

      - name: Downloading depot_tools
        run: docker exec -w /root ubuntu bash -c "git clone --single-branch --depth 1 https://chromium.googlesource.com/chromium/tools/depot_tools.git"

      - name: Running gclient runhooks
        run: docker exec -w /root ubuntu bash -c 'PATH=/root/depot_tools:$PATH gclient runhooks'

      - name: Generating build files
        run: docker exec -w /root/src ubuntu bash -c 'PATH=/root/depot_tools:$PATH gn gen out/android_arm'

      - name: Creating cache directory
        run: mkdir -p ./chrome_java_cache/

      - name: Gathering pre-compiled objects from cache
        uses: actions/cache@v1
        id: chrome_java_cache
        with:
          path: ./chrome_java_cache/
          key: ${{ runner.os }}-android_arm-chrome_java-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-android_arm-chrome_java-

      - name: Unpacking cache
        if: steps.chrome_java_cache.outputs.cache-hit == 'true'
        run: |
          docker cp ./chrome_java_cache/storage.lzma ubuntu:/root/storage.lzma
          docker exec -w /root ubuntu bash -c 'tar -xf ./storage.lzma -P -H posix --lzma'

      - name: Compiling chrome_java
        run: docker exec -w /root/src ubuntu bash -c 'PATH=/root/depot_tools:$PATH ninja -C out/android_arm chrome_java'

      - name: Compressing and collecting cache
        run: |
          docker exec -w /root ubuntu bash -c 'tar -cf storage.lzma -P -H posix --lzma /root/src/out/android_arm'
          docker cp ubuntu:/root/storage.lzma ./chrome_java_cache/storage.lzma

      - name: Compiling monochrome_java
        run: docker exec -w /root/src ubuntu bash -c 'PATH=/root/depot_tools:$PATH ninja -C out/android_arm monochrome_java'

      - name: Compiling chrome_public_apk
        run: docker exec -w /root/src ubuntu bash -c 'PATH=/root/depot_tools:$PATH ninja -C out/android_arm chrome_public_apk'

    #  - name: Deleting args.gn to not have it in cache
    #    run: docker exec -w /root/src ubuntu bash -c "rm -rvf out/android_arm/args.gn"

    #  - name: Uploading APK
    #    uses: actions/upload-artifact@v1
    #    with:
    #      name: apks
    #      path: src/out/android_arm/apks/
