#ifndef _ESEXTCTESSELLATIONSHADERTRIANGLES_HPP
#define _ESEXTCTESSELLATIONSHADERTRIANGLES_HPP
/*-------------------------------------------------------------------------
 * OpenGL Conformance Test Suite
 * -----------------------------
 *
 * Copyright (c) 2014-2016 The Khronos Group Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */ /*!
 * \file
 * \brief
 */ /*-------------------------------------------------------------------*/

#include "../esextcTestCaseBase.hpp"
#include "esextcTessellationShaderUtils.hpp"
#include "gluShaderUtil.hpp"
#include "tcuDefs.hpp"

namespace glcts
{
/** A DEQP CTS test group that collects all tests that verify triangle
 *  tessellation.
 */
class TessellationShaderTrianglesTests : public glcts::TestCaseGroupBase
{
public:
	/* Public methods */
	TessellationShaderTrianglesTests(glcts::Context& context, const ExtParameters& extParams);

	virtual ~TessellationShaderTrianglesTests(void)
	{
	}

	void init(void);

private:
	/* Private methods */
	TessellationShaderTrianglesTests(const TessellationShaderTrianglesTests& other);
	TessellationShaderTrianglesTests& operator=(const TessellationShaderTrianglesTests& other);
};

/** Implementation of Test Caes 29
 *
 *  Make sure that only a single triangle with (u,v,w) coordinates set to
 *  (0, 0, 1), (1, 0, 0) and (0, 1, 0) is generated by tessellation primitive
 *  generator if the first inner tessellation level and all three outer
 *  tessellation levels are set to one, equal_spacing or
 *  fractional_odd_spacing vertex spacing modes are used AND triangles
 *  geometry is requested.
 *
 *  The test should capture vertices output in TE stage, given the
 *  pre-conditions described in the test summary, and then verify vertex
 *  locations. Assume epsilon 1e-5. A single triangle should be drawn.
 *
 **/
class TessellationShaderTrianglesDegenerateTriangle : public TestCaseBase
{
public:
	/* Public methods */
	TessellationShaderTrianglesDegenerateTriangle(Context& context, const ExtParameters& extParams);

	virtual ~TessellationShaderTrianglesDegenerateTriangle(void)
	{
	}

	virtual void		  deinit(void);
	void				  initTest(void);
	virtual IterateResult iterate(void);

private:
	/* Private type definitions */
	typedef struct _test_descriptor
	{
		glw::GLuint							po_id;
		glw::GLuint							te_id;
		_tessellation_shader_vertex_spacing vertex_spacing;

		_test_descriptor()
		{
			po_id		   = 0;
			te_id		   = 0;
			vertex_spacing = TESSELLATION_SHADER_VERTEX_SPACING_UNKNOWN;
		}
	} _test_descriptor;

	typedef std::vector<_test_descriptor> _tests;
	typedef _tests::const_iterator		  _tests_const_iterator;

	/* Private methods */
	void deinitTestDescriptor(_test_descriptor& test);

	void initTestDescriptor(_test_descriptor& test, _tessellation_shader_vertex_spacing vertex_spacing);

	/* Private variables */
	glw::GLuint m_bo_id;
	glw::GLuint m_fs_id;
	glw::GLuint m_tc_id;
	glw::GLuint m_vs_id;
	glw::GLuint m_vao_id;

	_tests m_tests;
};

/** Implementation of Test Case 28
 *
 *  Make sure that modifying second inner tessellation level and fourth outer
 *  tessellation level does not affect geometry generated by tessellation
 *  primitive generator, while in triangles mode.
 *
 *  Technical details:
 *
 *  0. (adapted bullet 0 from test case 25:)
 *     Consider the following set: {1, MAX_TESS_GEN_LEVEL_EXT / 2,
 *     MAX_TESS_GEN_LEVEL_EXT}.
 *
 *  1. For all combinations of values from this set in regard to relevant
 *     inner/outer tessellation levels for triangles generator mode, two
 *     different output vertex sets should be captured in TE:
 *  1a. One for the configuration set considered;
 *  1b. The other one for the configuration set with an exception that
 *      second inner tessellation level and fourth outer tessellation level
 *      have been set to 1/4th of the original value.
 *  2. Test passes if all vertices from the first set can be found in the
 *     second set. (assume epsilon 1e-5)
 *
 **/
class TessellationShaderTrianglesIdenticalTriangles : public TestCaseBase
{
public:
	/* Public methods */
	TessellationShaderTrianglesIdenticalTriangles(Context& context, const ExtParameters& extParams);

	virtual ~TessellationShaderTrianglesIdenticalTriangles(void)
	{
	}

	virtual void		  deinit(void);
	void				  initTest(void);
	virtual IterateResult iterate(void);

private:
	/* Private type definitions */
	typedef struct _run
	{
		float base_inner[2];
		float base_outer[4];
		float reference_inner[2];
		float reference_outer[4];

		std::vector<char> base_data;
		std::vector<char> reference_data;
		unsigned int	  n_vertices;

		_run()
		{
			memset(base_inner, 0, sizeof(base_inner));
			memset(base_outer, 0, sizeof(base_outer));
			memset(reference_inner, 0, sizeof(reference_inner));
			memset(reference_outer, 0, sizeof(reference_outer));

			n_vertices = 0;
		}
	} _run;

	typedef std::vector<_run>	 _runs;
	typedef _runs::const_iterator _runs_const_iterator;

	/* Private variables */
	glw::GLuint				 m_vao_id;
	_runs					 m_runs;
	TessellationShaderUtils* m_utils;
};

/**  Implementation of Test Case 30
 *
 *   Consider triangle tessellation.
 *   Make sure that if inner tessellation level is set to one and any of the outer
 *   tessellation levels is greater than one, the inner tessellation level
 *   will be rounded up to two or three, depending on active vertex spacing mode.
 *
 *   Technical details:
 *
 *   0. Consider a set:
 *
 *      A = {2, MAX_TESS_GEN_LEVEL_EXT / 2, MAX_TESS_GEN_LEVEL_EXT};
 *
 *   1. For all values in A, and for all vertex spacing modes, let x be an
 *      iteration-specific value from the set.
 *   1a. Assuming an inner tessellation level set to 1 and outer tessellation level
 *       set to x, "draw" a single patch. Capture output vertices from TE stage.
 *   1b. Assuming an inner tessellation level set to 1 or 2 (depending on how
 *       the rounding should work for iteration-specific vertex ordering mode)
 *       and outer tessellation level set to x, "draw" a single patch. Capture
 *       output vertices from TE stage to another buffer object region.
 *   1c. Iteration passes if all vertices from the first captured set can be
 *       found in the second captured set. [assume epsilon 1e-5].
 *   2. Test passes if all iteration passed successfully.
 *
 **/
class TessellationShaderTrianglesInnerTessellationLevelRounding : public TestCaseBase
{
public:
	/* Public methods */
	TessellationShaderTrianglesInnerTessellationLevelRounding(Context& context, const ExtParameters& extParams);

	virtual ~TessellationShaderTrianglesInnerTessellationLevelRounding(void)
	{
	}

	virtual void		  deinit(void);
	virtual IterateResult iterate(void);
	void				  runTestIterations(void);

private:
	/* Private type definitions */
	typedef struct _run
	{
		float								set1_inner[2];
		float								set1_outer[4];
		float								set2_inner[2];
		float								set2_outer[4];
		_tessellation_shader_vertex_spacing vertex_spacing;

		std::vector<char> set1_data;
		std::vector<char> set2_data;
		unsigned int	  n_vertices;

		_run()
		{
			memset(set1_inner, 0, sizeof(set1_inner));
			memset(set1_outer, 0, sizeof(set1_outer));
			memset(set2_inner, 0, sizeof(set2_inner));
			memset(set2_outer, 0, sizeof(set2_outer));

			n_vertices	 = 0;
			vertex_spacing = TESSELLATION_SHADER_VERTEX_SPACING_UNKNOWN;
		}
	} _run;

	typedef std::vector<_run>	 _runs;
	typedef _runs::const_iterator _runs_const_iterator;

	/* Private variables */
	glw::GLuint				 m_vao_id;
	_runs					 m_runs;
	TessellationShaderUtils* m_utils;
};

} // namespace glcts

#endif // _ESEXTCTESSELLATIONSHADERTRIANGLES_HPP
