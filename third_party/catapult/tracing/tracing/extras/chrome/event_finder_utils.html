<!DOCTYPE html>
<!--
Copyright 2017 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/math/range.html">
<link rel="import" href="/tracing/metrics/system_health/utils.html">

<script>
'use strict';

tr.exportTo('tr.e.chrome', function() {
  // We want to ignore chrome internal URLs when computing metrics.
  const CHROME_INTERNAL_URLS = [
    // Blank URLs are usually initial empty document.
    '',
    'about:blank',
    // Chrome on Android creates main frames with the below URL for plugins.
    'data:text/html,pluginplaceholderdata',
    // Special URL used to start a navigation to an unreachable error page.
    'chrome-error://chromewebdata/'
  ];
  // Titles for top level tasks in the scheduler. Any input event queued during
  // a top level task cannot be handled until the end of that task.
  const TOP_LEVEL_TASK_TITLES = [
    // Old name of scheduler top level tasks. Preserved for backwards
    // compatibility with old traces.
    'TaskQueueManager::ProcessTaskFromWorkQueue',
    // This is the name of top level scheduler tasks as of
    // https://crrev.com/c/883346.
    'ThreadControllerImpl::DoWork',
  ];

  /**
   * Utility class providing methods to efficiently find events.
   * TODO(4023) This should be merged with thread/process helper.
   */
  class EventFinderUtils {
    /**
     * Returns true if |category| is one of the categories of |event|, and
     * |event| has title |title|.
     *
     * TODO(dproy): Make this a method on a suitable parent class of the
     * event/slice classes that are used with this function.
     */
    static hasCategoryAndName(event, category, title) {
      return event.title === title && event.category &&
        tr.b.getCategoryParts(event.category).includes(category);
    }

    /**
     * Returns a map of frame id to main thread slices of |rendererHelper| with
     * title |eventTitle| and categry |eventCategory|, sorted by start
     * time. Returned slices do not include telemetry internal events.
     *
     * @param {tr.model.helpers.ChromeRendererHelper} rendererHelper
     * @param {string} eventTitle
     * @param {string} eventCategory
     * @returns {Map.<string, Array<!tr.model.ThreadSlice>>}
     */
    static getSortedMainThreadEventsByFrame(
        rendererHelper, eventTitle, eventCategory) {
      const eventsByFrame = new Map();

      // Events yielded by childEvents() are sorted by start time.
      for (const ev of rendererHelper.mainThread.sliceGroup.childEvents()) {
        if (rendererHelper.isTelemetryInternalEvent(ev)) continue;
        if (!this.hasCategoryAndName(ev, eventCategory, eventTitle)) {
          continue;
        }

        const frameIdRef = ev.args.frame;
        if (frameIdRef === undefined) continue;
        if (!eventsByFrame.has(frameIdRef)) {
          eventsByFrame.set(frameIdRef, []);
        }
        eventsByFrame.get(frameIdRef).push(ev);
      }

      return eventsByFrame;
    }

    /**
     * Returns latest event in |sortedEvents| that starts on or before
     * |timestamp|, or undefined if no such event exists.
     *
     * @param {!Array<!tr.model.TimedEvent>} sortedEvents - events sorted by
     *     start time.
     * @param {number} timestamp
     * @returns {tr.model.TimedEvent|undefined}
     */
    static findLastEventStartingOnOrBeforeTimestamp(sortedEvents, timestamp) {
      const firstIndexAfterTimestamp =
          tr.b.findFirstTrueIndexInSortedArray(
              sortedEvents, e => e.start > timestamp);
      // We found the first index after the timestamp, so the index immediately
      // before it is the index we're looking for. If the first index after
      // timestamp is 0, then there is no index on or before timestamp.
      if (firstIndexAfterTimestamp === 0) return undefined;
      return sortedEvents[firstIndexAfterTimestamp - 1];
    }

    /**
     * Returns latest event in |sortedEvents| that starts before
     * |timestamp|, or undefined if no such event exists.
     *
     * @param {!Array<!tr.model.TimedEvent>} sortedEvents - events sorted by
     *     start time.
     * @param {number} timestamp
     * @returns {tr.model.TimedEvent|undefined}
     */
    static findLastEventStartingBeforeTimestamp(sortedEvents, timestamp) {
      const firstIndexAfterTimestamp =
          tr.b.findFirstTrueIndexInSortedArray(
              sortedEvents, e => e.start >= timestamp);
      // We found the first index after the timestamp, so the index immediately
      // before it is the index we're looking for. If the first index after
      // timestamp is 0, then there is no index on or before timestamp.
      if (firstIndexAfterTimestamp === 0) return undefined;
      return sortedEvents[firstIndexAfterTimestamp - 1];
    }


    /**
     * Returns earliest event in |sortedEvents| that starts on or after
     * |timestamp|, or undefined if no such event exists.
     *
     * @param {!Array<!tr.model.TimedEvent>} sortedEvents - events sorted by
     *     start time.
     * @param {number} timestamp
     * @returns {tr.model.Event|undefined}
     */
    static findNextEventStartingOnOrAfterTimestamp(sortedEvents, timestamp) {
      const firstIndexOnOrAfterTimestamp =
          tr.b.findFirstTrueIndexInSortedArray(
              sortedEvents, e => e.start >= timestamp);

      if (firstIndexOnOrAfterTimestamp === sortedEvents.length) {
        return undefined;
      }
      return sortedEvents[firstIndexOnOrAfterTimestamp];
    }

    /**
     * Returns earliest event in |sortedEvents| that starts after |timestamp|,
     * or undefined if no such event exists.
     *
     * @param {!Array<!tr.model.TimedEvent>} sortedEvents - events sorted by
     *     start time.
     * @param {number} timestamp
     * @returns {tr.model.Event|undefined}
     */
    static findNextEventStartingAfterTimestamp(sortedEvents, timestamp) {
      const firstIndexOnOrAfterTimestamp =
          tr.b.findFirstTrueIndexInSortedArray(
              sortedEvents, e => e.start > timestamp);

      if (firstIndexOnOrAfterTimestamp === sortedEvents.length) {
        return undefined;
      }
      return sortedEvents[firstIndexOnOrAfterTimestamp];
    }

    /**
     * Returns a list of top level scheduler tasks.
     * It is used by TTI and EQT metrics.
     * @param {!tr.model.Thread} mainThread - the main thead of the renderer.
     * @returns {!Array<tr.model.Slice>}
     */
    static findToplevelSchedulerTasks(mainThread) {
      const titles = new Set(TOP_LEVEL_TASK_TITLES);
      const tasks = [];
      tasks.push(...mainThread.findTopmostSlices(
          slice => titles.has(slice.title)));
      return tasks;
    }
  }

  return {
    EventFinderUtils,
    CHROME_INTERNAL_URLS,
  };
});
</script>
