<!DOCTYPE html>
<!--
Copyright (c) 2012 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/extras/importer/linux_perf/parser.html">

<script>
'use strict';

/**
 * @fileoverview Parses cpufreq events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const ColorScheme = tr.b.ColorScheme;
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux cpufreq trace events.
   * @constructor
   */
  function CpufreqParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('cpufreq_interactive_up',
        CpufreqParser.prototype.cpufreqUpDownEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_down',
        CpufreqParser.prototype.cpufreqUpDownEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_already',
        CpufreqParser.prototype.cpufreqTargetEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_notyet',
        CpufreqParser.prototype.cpufreqTargetEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_setspeed',
        CpufreqParser.prototype.cpufreqTargetEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_target',
        CpufreqParser.prototype.cpufreqTargetEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_boost',
        CpufreqParser.prototype.cpufreqBoostUnboostEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_unboost',
        CpufreqParser.prototype.cpufreqBoostUnboostEvent.bind(this));
  }

  function splitData(input) {
    // TODO(sleffler) split by cpu
    const data = {};
    const args = input.split(/\s+/);
    const len = args.length;
    for (let i = 0; i < len; i++) {
      const item = args[i].split('=');
      data[item[0]] = parseInt(item[1]);
    }
    return data;
  }

  CpufreqParser.prototype = {
    __proto__: Parser.prototype,

    cpufreqSlice(ts, eventName, cpu, args) {
      // TODO(sleffler) should be per-cpu
      const kthread = this.importer.getOrCreatePseudoThread('cpufreq');
      kthread.openSlice = eventName;
      const slice = new tr.model.ThreadSlice('', kthread.openSlice,
          ColorScheme.getColorIdForGeneralPurposeString(kthread.openSlice),
          ts, args, 0);

      kthread.thread.sliceGroup.pushSlice(slice);
    },

    cpufreqBoostSlice(ts, eventName, args) {
      const kthread = this.importer.getOrCreatePseudoThread('cpufreq_boost');
      kthread.openSlice = eventName;
      const slice = new tr.model.ThreadSlice('', kthread.openSlice,
          ColorScheme.getColorIdForGeneralPurposeString(kthread.openSlice),
          ts, args, 0);

      kthread.thread.sliceGroup.pushSlice(slice);
    },

    /**
     * Parses cpufreq events and sets up state in the importer.
     */
    cpufreqUpDownEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const data = splitData(eventBase.details);
      this.cpufreqSlice(ts, eventName, data.cpu, data);
      return true;
    },

    cpufreqTargetEvent(eventName, cpuNumber, pid, ts,
        eventBase) {
      const data = splitData(eventBase.details);
      this.cpufreqSlice(ts, eventName, data.cpu, data);
      return true;
    },

    cpufreqBoostUnboostEvent(eventName, cpuNumber, pid, ts,
        eventBase) {
      this.cpufreqBoostSlice(ts, eventName,
          {
            type: eventBase.details
          });
      return true;
    }
  };

  Parser.register(CpufreqParser);

  return {
    CpufreqParser,
  };
});
</script>

