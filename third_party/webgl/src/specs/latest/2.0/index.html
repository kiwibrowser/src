<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>WebGL 2.0 Specification</title>
    <link rel="stylesheet" type="text/css" href="../../../resources/Khronos-WD.css" />
    <script src="../../../resources/jquery-1.3.2.min.js" type="application/javascript"></script>
    <script src="../../../resources/generateTOC.js" type="application/javascript"></script>
</head>
<body onload="generateTOC(document.getElementById('toc'))">
    <!--begin-logo-->
    <div class="head">
        <div class="left">
            <p>
                <a href="http://webgl.org/">
                    <img alt="WebGL" width="240" height="100" src="../../../resources/WebGL-Logo.png"/>
                </a>
            </p>
        </div>
        <div class="right">
            <p>
                <a href="http://khronos.org/">
                    <img alt=Khronos height=60 src="../../../resources/KhronosGroup-3D.png" width=220>
                </a>
            </p>
        </div>
    </div>
    <div style="clear: both;"></div>
    <!--end-logo-->

    <h1>WebGL 2.0 Specification</h1>
    <h2 class="no-toc">Editor's Draft <span id="LastEditDate"></span></h2>
    <dl>
        <dt>This version:
            <dd>
                <a href="https://www.khronos.org/registry/webgl/specs/latest/2.0/">
                    https://www.khronos.org/registry/webgl/specs/latest/2.0/
                </a>
                <br>
                <a href="https://www.khronos.org/registry/webgl/specs/latest/2.0/webgl2.idl">
                    <b>WebIDL:</b> https://www.khronos.org/registry/webgl/specs/latest/2.0/webgl2.idl
                </a>
            </dd>
        <dt>Latest version:
            <dd>
                <a href="https://www.khronos.org/registry/webgl/specs/latest/2.0/">
                    https://www.khronos.org/registry/webgl/specs/latest/2.0/
                </a>
                <br>
                <a href="https://www.khronos.org/registry/webgl/specs/latest/2.0/webgl2.idl">
                    <b>WebIDL:</b> https://www.khronos.org/registry/webgl/specs/latest/2.0/webgl2.idl
                </a>
            </dd>
        <dt>Previous version:
            <dd>
                <a href="https://www.khronos.org/registry/webgl/specs/1.0.2/">
                    https://www.khronos.org/registry/webgl/specs/1.0.2/
                </a>
                <br>
                <a href="https://www.khronos.org/registry/webgl/specs/1.0.2/webgl.idl">
                    <b>WebIDL:</b> https://www.khronos.org/registry/webgl/specs/1.0.2/webgl.idl
                </a>
            </dd>
        <dt>Editors:
            <dd>
                <a href="mailto:dino@apple.com">Dean Jackson</a>
                <a href="http://www.apple.com/">(Apple Inc.)</a>
            </dd>
            <dd>
                <a href="mailto:jgilbert@mozilla.com">Jeff Gilbert</a>
                <a href="https://www.mozilla.org/">(Mozilla Corp.)</a>
            </dd>
    </dl>

    <span style="font-size: x-small; font-style: oblique">Copyright &copy; 2015 Khronos Group</span>

    <hr />

    <h2 class="no-toc">Abstract</h2>
    <p>
        This is Version 2.0 of the WebGL Specification.
    </p>
    <p>
        This specification describes an additional rendering context and support
        objects for the
        <a href="http://www.w3.org/TR/html5/the-canvas-element.html"
           title="HTML 5 Canvas Element">
            HTML 5 <span class="prop-name">canvas</span> element <a href="#refsCANVAS">[CANVAS]</a>.
        </a>
        This context allows rendering using an API that conforms closely to the OpenGL ES 3.0 API.
    </p>
    <p>
      This document should be read as an extension to the <a href="https://www.khronos.org/registry/webgl/specs/latest/1.0/">
        WebGL 1.0 specification</a>. It will only describe the differences from 1.0.</a>

    <h2 class="no-toc">Status of this document</h2>

    <!--begin-status-->
    <p>
        This document is an editor's draft. Do not cite this document as other than work in
        progress.
    </p>
    <!--end-status-->

    <h2 class="no-toc">Feedback</h2>
    <p>
        Public discussion of this specification is welcome on
        the <a href="mailto:public_webgl@khronos.org">public_webgl@khronos.org</a> mailing list
        (<a href="http://www.khronos.org/webgl/public-mailing-list/">instructions</a>, <a href="https://www.khronos.org/webgl/public-mailing-list/archives/">archives</a>).
    </p>
    <p>
        Please file bugs against the specification or its conformance tests in
        the <a href="https://github.com/KhronosGroup/WebGL/issues">issue tracker</a>. Pull requests
        are welcome against the <a href="https://github.com/KhronosGroup/WebGL">Github
        repository</a>.
    </p>

    <h2 class="no-toc">Table of contents</h2>
    <div id="toc"></div>

    <h2>Introduction</h2>
    <div class="note">
    <p>
      WebGL™ is an immediate mode 3D rendering API designed for the web. This is Version 2 of the
      WebGL specification. It is derived from OpenGL® ES 3.0, and provides similar rendering
      functionality, but in an HTML context.
    </p>

    <p>
      WebGL 2.0 is not entirely backwards compatible with WebGL 1.0. Existing error-free content written
      against the core WebGL 1.0 specification without extensions will often run in WebGL 2.0 without
      modification, but this is not always the case. All exceptions to backwards compatibility are
      recorded in the <a href="#BACKWARDS_INCOMPATIBILITY">Backwards Incompatibility</a> section.
      To access the new behavior provided in this specification, the content explicitly requests
      a new context (<a href="#CONTEXT_CREATION">details below</a>).
    </p>
    </div>

    <h3>Conventions</h3>

    <p>
     Many functions described in this document contain links to OpenGL ES
     man pages. While every effort is made to make these pages match the
     OpenGL ES 3.0 specification <a href="#refsGLES30">[GLES30]</a>,
     they may contain errors. In the case of a contradiction, the OpenGL
     ES 3.0 specification is the final authority.
    </p>

    <p>
      The remaining sections of this document are intended to be read in conjunction
      with the OpenGL ES 3.0 specification (3.0.4 at the time of this writing, available
      from the <a href="http://www.khronos.org/registry/gles/">Khronos OpenGL ES API Registry</a>).
      Unless otherwise specified, the behavior of each method is defined by the
      OpenGL ES 3.0 specification.  This specification may diverge from OpenGL ES 3.0
      in order to ensure interoperability or security, often defining areas that
      OpenGL ES 3.0 leaves implementation-defined.  These differences are summarized in the
      <a href="#webgl_gl_differences">Differences Between WebGL and OpenGL ES 3.0</a> section.
    </p>

<!-- ======================================================================================================= -->

    <h2>Context Creation and Drawing Buffer Presentation</h2>

    <p>
        Before using the WebGL API, the author must obtain a <code>WebGLRenderingContext</code>
        object for a given HTMLCanvasElement <a href="#refsCANVAS">[CANVAS]</a> as described
        below. This object is used to manage OpenGL state and render to the drawing buffer, which
        must be created at the time of context creation.
    </p>

<!-- ======================================================================================================= -->

    <h3><a name="CONTEXT_CREATION">Context Creation</a></h3>

    <p>
        Each <code>WebGLRenderingContext</code> and <code>WebGL2RenderingContext</code> has an
        associated <b><a name="context-canvas">canvas</a></b>, set upon creation, which is
        a <em>canvas</em> <a href="#refsCANVAS">[CANVAS]</a>.
    </p>
    <p>
        Each <code>WebGLRenderingContext</code> and <code>WebGL2RenderingContext</code> has <b><a name="context-creation-parameters">context
        creation parameters</a></b>, set upon creation, in
        a <a href="../1.0/index.html#WEBGLCONTEXTATTRIBUTES"><code>WebGLContextAttributes</code></a> object.
    </p>
    <p>
        Each <code>WebGLRenderingContext</code> and <code>WebGL2RenderingContext</code> has <b><a name="actual-context-parameters">actual
        context parameters</a></b>, set each time the drawing buffer is created, in
        a <a href="../1.0/index.html#WEBGLCONTEXTATTRIBUTES"><code>WebGLContextAttributes</code></a> object.
    </p>
    <p>
        Each <code>WebGLRenderingContext</code> and <code>WebGL2RenderingContext</code> has a <b><a name="webgl-context-lost-flag">webgl
        context lost flag</a></b>, which is initially unset.
    </p>
    <p>
        When the <code>getContext()</code> method of a <code>canvas</code> element is to return a
        new object for
        the <em>contextId</em> <code>webgl2</code> <a href="#refsCANVASCONTEXTS">[CANVASCONTEXTS]</a>,
        the user agent must perform the following steps:

        <ol class="nestedlist">

        <li> Create a new <code>WebGL2RenderingContext</code> object, <em>context</em>.

        <li> Let <em>context's</em> <a href="#context-canvas">canvas</a> be the canvas
             the <code>getContext()</code> method is associated with.

        <li> Create a new <code>WebGLContextAttributes</code> object, <em>contextAttributes</em>.

        <li> If <code>getContext()</code> was invoked with a second argument, <em>options</em>, set
             the attributes of <em>contextAttributes</em> from those specified in <em>options</em>.

        <li> <a href="#create-a-drawing-buffer">Create a <em>drawing buffer</em></a> using the settings
             specified in <em>contextAttributes</em>, and associate the <em>drawing buffer</em>
             with <em>context</em>.

        <li> If drawing buffer creation failed, perform the following steps:

          <ol class="nestedlist">

          <li> <a href="#fire-a-webgl-context-creation-error">Fire a WebGL context creation
          error</a> at <em>canvas</em>.

          <li> Return null and terminate these steps.

          </ol>

        <li> Create a new <code>WebGLContextAttributes</code> object, <em>actualAttributes</em>.

        <li> Set the attributes of <em>actualAttributes</em> based on the properties of the newly
             created drawing buffer.

        <li> Set <em>context's</em> <a href="#context-creation-parameters">context creation
        parameters</a> to <em>contextAttributes</em>.

        <li> Set <em>context's</em> <a href="#actual-context-parameters">actual context
        parameters</a> to <em>actualAttributes</em>.

        <li> Return <em>context</em>.

        </ol>
    </p>

    <h3><a name="CONTEXT_CREATION">The Drawing Buffer</a></h3>

    <p>
    Different from WebGL 1.0, the <code>depth</code>, <code>stencil</code>, and
    <code>antialias</code> attributes in WebGL 2.0 must be obeyed by the WebGL
    implementation.
    </p>

<!-- ======================================================================================================= -->

    <h2>DOM Interfaces</h2>

    <p>
        This section describes the interfaces and functionality added to the
        DOM to support runtime access to the functionality described above.
    </p>

    <!-- ======================================================================================================= -->

    <h3>Types</h3>

    <p>
      The following types are introduced in WebGL 2.0.
    </p>
    <pre class="idl">
typedef long long GLint64;
typedef unsigned long long GLuint64;
</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLQuery</h3>

    <p>
        The <code>WebGLQuery</code> interface represents an OpenGL Query Object.
        The underlying object is created as if by calling glGenQueries
        <span class="gl-spec">
          (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.13">OpenGL ES 3.0.4 &sect;2.13</a>,
          <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glGenQueries.xhtml">man page</a>)
        </span>,
        made active as if by calling glBeginQuery
        <span class="gl-spec">
          (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.13">OpenGL ES 3.0.4 &sect;2.13</a>,
          <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glBeginQuery.xhtml">man page</a>)
        </span>,
        concluded as if by calling glEndQuery
        <span class="gl-spec">
          (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.13">OpenGL ES 3.0.4 &sect;2.13</a>,
          <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glBeginQuery.xhtml">man page</a>)
        </span>
        and destroyed as if by calling glDeleteQueries
        <span class="gl-spec">
          (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.13">OpenGL ES 3.0.4 &sect;2.13</a>,
          <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glDeleteQueries.xhtml">man page</a>)
        </span>.
    </p>
    <pre class="idl">interface <dfn id="WebGLQuery">WebGLQuery</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLSampler</h3>

    <p>
        The <code>WebGLSampler</code> interface represents an OpenGL Sampler Object.
        The underlying object is created as if by calling glGenSamplers
        <span class="gl-spec">
          (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.2">OpenGL ES 3.0.4 &sect;3.8.2</a>,
          <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glGenSamplers.xhtml">man page</a>)
        </span>,
         bound as if by calling glBindSampler
        <span class="gl-spec">
          (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.2">OpenGL ES 3.0.4 &sect;3.8.2</a>,
          <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glBindSampler.xhtml">man page</a>)
        </span>
        and destroyed as if by calling glDeleteSamplers
        <span class="gl-spec">
          (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.2">OpenGL ES 3.0.4 &sect;3.8.2</a>,
          <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glDeleteSamplers.xhtml">man page</a>)
        </span>.
    </p>
    <pre class="idl">interface <dfn id="WebGLSampler">WebGLSampler</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLSync</h3>

    <p>
        The <code>WebGLSync</code> interface represents an OpenGL Sync Object.
        The underlying object is created as if by calling glFenceSync
        <span class="gl-spec">
          (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-5.2">OpenGL ES 3.0.4 &sect;5.2</a>,
          <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glFenceSync.xhtml">man page</a>)
        </span>,
        blocked on as if by calling glClientWaitSync
        <span class="gl-spec">
          (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-5.2.1">OpenGL ES 3.0.4 &sect;5.2.1</a>,
          <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glClientWaitSync.xhtml">man page</a>)
        </span>,
        waited on internal to GL as if by calling glWaitSync
        <span class="gl-spec">
          (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-5.2.1">OpenGL ES 3.0.4 &sect;5.2.1</a>,
          <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glWaitSync.xhtml">man page</a>)
        </span>,
        queried as if by calling glGetSynciv
        <span class="gl-spec">
          (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-6.1.8">OpenGL ES 3.0.4 &sect;6.2.8</a>,
          <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glGetSynciv.xhtml">man page</a>)
        </span>,
        and destroyed as if by calling glDeleteSync
        <span class="gl-spec">
          (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-5.2">OpenGL ES 3.0.4 &sect;5.2</a>,
          <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glDeleteSync.xhtml">man page</a>)
        </span>.
    </p>
    <p>
    </p>
    <pre class="idl">interface <dfn id="WebGLSync">WebGLSync</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLTransformFeedback</h3>

    <p>
        The <code>WebGLTransformFeedback</code> interface represents an OpenGL Transform Feedback Object.
        The underlying object is created as if by calling glGenTransformFeedbacks
        <span class="gl-spec">
          (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.14.1">OpenGL ES 3.0.4 &sect;2.14.1</a>,
          <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glGenTransformFeedbacks.xhtml">man page</a>)
        </span>,
        bound as if by calling glBindTransformFeedback
        <span class="gl-spec">
          (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.14.1">OpenGL ES 3.0.4 &sect;2.14.1</a>,
          <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glBindTransformFeedback.xhtml">man page</a>)
        </span>
        and destroyed as if by calling glDeleteTransformFeedbacks
        <span class="gl-spec">
          (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.14.1">OpenGL ES 3.0.4 &sect;2.14.1</a>,
          <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glDeleteTransformFeedbacks.xhtml">man page</a>)
        </span>.
    </p>
    <pre class="idl">interface <dfn id="WebGLTransformFeedback">WebGLTransformFeedback</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLVertexArrayObject</h3>

    <p>
        The <code>WebGLVertexArrayObject</code> interface represents an OpenGL Vertex Array Object.
        The underlying object is created as if by calling glGenVertexArrays
        <span class="gl-spec">
          (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.10">OpenGL ES 3.0.4 &sect;2.10</a>,
          <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glGenVertexArrays.xhtml">man page</a>)
        </span>,
        bound as if by calling glBindVertexArray
        <span class="gl-spec">
          (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.10">OpenGL ES 3.0.4 &sect;2.10</a>,
          <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glBindVertexArray.xhtml">man page</a>)
        </span>
        and destroyed as if by calling glDeleteVertexArrays
        <span class="gl-spec">
          (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.10">OpenGL ES 3.0.4 &sect;2.10</a>,
          <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glDeleteVertexArrays.xhtml">man page</a>)
        </span>.
    </p>
    <pre class="idl">interface <dfn id="WebGLVertexArrayObject">WebGLVertexArrayObject</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3><a name="WEBGLRENDERINGCONTEXT">The WebGL context</a></h3>

    <p>
        The <code>WebGL2RenderingContext</code> represents the API allowing
        OpenGL ES 3.0 style rendering into the canvas element.
    </p>

    <pre class="idl">
typedef ([AllowShared] Uint32Array or sequence&lt;GLuint&gt;) Uint32List;

interface mixin <dfn id="WebGL2RenderingContextBase">WebGL2RenderingContextBase</dfn>
{
  const GLenum READ_BUFFER                                   = 0x0C02;
  const GLenum UNPACK_ROW_LENGTH                             = 0x0CF2;
  const GLenum UNPACK_SKIP_ROWS                              = 0x0CF3;
  const GLenum UNPACK_SKIP_PIXELS                            = 0x0CF4;
  const GLenum PACK_ROW_LENGTH                               = 0x0D02;
  const GLenum PACK_SKIP_ROWS                                = 0x0D03;
  const GLenum PACK_SKIP_PIXELS                              = 0x0D04;
  const GLenum COLOR                                         = 0x1800;
  const GLenum DEPTH                                         = 0x1801;
  const GLenum STENCIL                                       = 0x1802;
  const GLenum RED                                           = 0x1903;
  const GLenum RGB8                                          = 0x8051;
  const GLenum RGBA8                                         = 0x8058;
  const GLenum RGB10_A2                                      = 0x8059;
  const GLenum TEXTURE_BINDING_3D                            = 0x806A;
  const GLenum UNPACK_SKIP_IMAGES                            = 0x806D;
  const GLenum UNPACK_IMAGE_HEIGHT                           = 0x806E;
  const GLenum TEXTURE_3D                                    = 0x806F;
  const GLenum TEXTURE_WRAP_R                                = 0x8072;
  const GLenum MAX_3D_TEXTURE_SIZE                           = 0x8073;
  const GLenum UNSIGNED_INT_2_10_10_10_REV                   = 0x8368;
  const GLenum MAX_ELEMENTS_VERTICES                         = 0x80E8;
  const GLenum MAX_ELEMENTS_INDICES                          = 0x80E9;
  const GLenum TEXTURE_MIN_LOD                               = 0x813A;
  const GLenum TEXTURE_MAX_LOD                               = 0x813B;
  const GLenum TEXTURE_BASE_LEVEL                            = 0x813C;
  const GLenum TEXTURE_MAX_LEVEL                             = 0x813D;
  const GLenum MIN                                           = 0x8007;
  const GLenum MAX                                           = 0x8008;
  const GLenum DEPTH_COMPONENT24                             = 0x81A6;
  const GLenum MAX_TEXTURE_LOD_BIAS                          = 0x84FD;
  const GLenum TEXTURE_COMPARE_MODE                          = 0x884C;
  const GLenum TEXTURE_COMPARE_FUNC                          = 0x884D;
  const GLenum CURRENT_QUERY                                 = 0x8865;
  const GLenum QUERY_RESULT                                  = 0x8866;
  const GLenum QUERY_RESULT_AVAILABLE                        = 0x8867;
  const GLenum STREAM_READ                                   = 0x88E1;
  const GLenum STREAM_COPY                                   = 0x88E2;
  const GLenum STATIC_READ                                   = 0x88E5;
  const GLenum STATIC_COPY                                   = 0x88E6;
  const GLenum DYNAMIC_READ                                  = 0x88E9;
  const GLenum DYNAMIC_COPY                                  = 0x88EA;
  const GLenum MAX_DRAW_BUFFERS                              = 0x8824;
  const GLenum DRAW_BUFFER0                                  = 0x8825;
  const GLenum DRAW_BUFFER1                                  = 0x8826;
  const GLenum DRAW_BUFFER2                                  = 0x8827;
  const GLenum DRAW_BUFFER3                                  = 0x8828;
  const GLenum DRAW_BUFFER4                                  = 0x8829;
  const GLenum DRAW_BUFFER5                                  = 0x882A;
  const GLenum DRAW_BUFFER6                                  = 0x882B;
  const GLenum DRAW_BUFFER7                                  = 0x882C;
  const GLenum DRAW_BUFFER8                                  = 0x882D;
  const GLenum DRAW_BUFFER9                                  = 0x882E;
  const GLenum DRAW_BUFFER10                                 = 0x882F;
  const GLenum DRAW_BUFFER11                                 = 0x8830;
  const GLenum DRAW_BUFFER12                                 = 0x8831;
  const GLenum DRAW_BUFFER13                                 = 0x8832;
  const GLenum DRAW_BUFFER14                                 = 0x8833;
  const GLenum DRAW_BUFFER15                                 = 0x8834;
  const GLenum MAX_FRAGMENT_UNIFORM_COMPONENTS               = 0x8B49;
  const GLenum MAX_VERTEX_UNIFORM_COMPONENTS                 = 0x8B4A;
  const GLenum SAMPLER_3D                                    = 0x8B5F;
  const GLenum SAMPLER_2D_SHADOW                             = 0x8B62;
  const GLenum FRAGMENT_SHADER_DERIVATIVE_HINT               = 0x8B8B;
  const GLenum PIXEL_PACK_BUFFER                             = 0x88EB;
  const GLenum PIXEL_UNPACK_BUFFER                           = 0x88EC;
  const GLenum PIXEL_PACK_BUFFER_BINDING                     = 0x88ED;
  const GLenum PIXEL_UNPACK_BUFFER_BINDING                   = 0x88EF;
  const GLenum FLOAT_MAT2x3                                  = 0x8B65;
  const GLenum FLOAT_MAT2x4                                  = 0x8B66;
  const GLenum FLOAT_MAT3x2                                  = 0x8B67;
  const GLenum FLOAT_MAT3x4                                  = 0x8B68;
  const GLenum FLOAT_MAT4x2                                  = 0x8B69;
  const GLenum FLOAT_MAT4x3                                  = 0x8B6A;
  const GLenum SRGB                                          = 0x8C40;
  const GLenum SRGB8                                         = 0x8C41;
  const GLenum SRGB8_ALPHA8                                  = 0x8C43;
  const GLenum COMPARE_REF_TO_TEXTURE                        = 0x884E;
  const GLenum RGBA32F                                       = 0x8814;
  const GLenum RGB32F                                        = 0x8815;
  const GLenum RGBA16F                                       = 0x881A;
  const GLenum RGB16F                                        = 0x881B;
  const GLenum VERTEX_ATTRIB_ARRAY_INTEGER                   = 0x88FD;
  const GLenum MAX_ARRAY_TEXTURE_LAYERS                      = 0x88FF;
  const GLenum MIN_PROGRAM_TEXEL_OFFSET                      = 0x8904;
  const GLenum MAX_PROGRAM_TEXEL_OFFSET                      = 0x8905;
  const GLenum MAX_VARYING_COMPONENTS                        = 0x8B4B;
  const GLenum TEXTURE_2D_ARRAY                              = 0x8C1A;
  const GLenum TEXTURE_BINDING_2D_ARRAY                      = 0x8C1D;
  const GLenum R11F_G11F_B10F                                = 0x8C3A;
  const GLenum UNSIGNED_INT_10F_11F_11F_REV                  = 0x8C3B;
  const GLenum RGB9_E5                                       = 0x8C3D;
  const GLenum UNSIGNED_INT_5_9_9_9_REV                      = 0x8C3E;
  const GLenum TRANSFORM_FEEDBACK_BUFFER_MODE                = 0x8C7F;
  const GLenum MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS    = 0x8C80;
  const GLenum TRANSFORM_FEEDBACK_VARYINGS                   = 0x8C83;
  const GLenum TRANSFORM_FEEDBACK_BUFFER_START               = 0x8C84;
  const GLenum TRANSFORM_FEEDBACK_BUFFER_SIZE                = 0x8C85;
  const GLenum TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN         = 0x8C88;
  const GLenum RASTERIZER_DISCARD                            = 0x8C89;
  const GLenum MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 0x8C8A;
  const GLenum MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS       = 0x8C8B;
  const GLenum INTERLEAVED_ATTRIBS                           = 0x8C8C;
  const GLenum SEPARATE_ATTRIBS                              = 0x8C8D;
  const GLenum TRANSFORM_FEEDBACK_BUFFER                     = 0x8C8E;
  const GLenum TRANSFORM_FEEDBACK_BUFFER_BINDING             = 0x8C8F;
  const GLenum RGBA32UI                                      = 0x8D70;
  const GLenum RGB32UI                                       = 0x8D71;
  const GLenum RGBA16UI                                      = 0x8D76;
  const GLenum RGB16UI                                       = 0x8D77;
  const GLenum RGBA8UI                                       = 0x8D7C;
  const GLenum RGB8UI                                        = 0x8D7D;
  const GLenum RGBA32I                                       = 0x8D82;
  const GLenum RGB32I                                        = 0x8D83;
  const GLenum RGBA16I                                       = 0x8D88;
  const GLenum RGB16I                                        = 0x8D89;
  const GLenum RGBA8I                                        = 0x8D8E;
  const GLenum RGB8I                                         = 0x8D8F;
  const GLenum RED_INTEGER                                   = 0x8D94;
  const GLenum RGB_INTEGER                                   = 0x8D98;
  const GLenum RGBA_INTEGER                                  = 0x8D99;
  const GLenum SAMPLER_2D_ARRAY                              = 0x8DC1;
  const GLenum SAMPLER_2D_ARRAY_SHADOW                       = 0x8DC4;
  const GLenum SAMPLER_CUBE_SHADOW                           = 0x8DC5;
  const GLenum UNSIGNED_INT_VEC2                             = 0x8DC6;
  const GLenum UNSIGNED_INT_VEC3                             = 0x8DC7;
  const GLenum UNSIGNED_INT_VEC4                             = 0x8DC8;
  const GLenum INT_SAMPLER_2D                                = 0x8DCA;
  const GLenum INT_SAMPLER_3D                                = 0x8DCB;
  const GLenum INT_SAMPLER_CUBE                              = 0x8DCC;
  const GLenum INT_SAMPLER_2D_ARRAY                          = 0x8DCF;
  const GLenum UNSIGNED_INT_SAMPLER_2D                       = 0x8DD2;
  const GLenum UNSIGNED_INT_SAMPLER_3D                       = 0x8DD3;
  const GLenum UNSIGNED_INT_SAMPLER_CUBE                     = 0x8DD4;
  const GLenum UNSIGNED_INT_SAMPLER_2D_ARRAY                 = 0x8DD7;
  const GLenum DEPTH_COMPONENT32F                            = 0x8CAC;
  const GLenum DEPTH32F_STENCIL8                             = 0x8CAD;
  const GLenum FLOAT_32_UNSIGNED_INT_24_8_REV                = 0x8DAD;
  const GLenum FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING         = 0x8210;
  const GLenum FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE         = 0x8211;
  const GLenum FRAMEBUFFER_ATTACHMENT_RED_SIZE               = 0x8212;
  const GLenum FRAMEBUFFER_ATTACHMENT_GREEN_SIZE             = 0x8213;
  const GLenum FRAMEBUFFER_ATTACHMENT_BLUE_SIZE              = 0x8214;
  const GLenum FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE             = 0x8215;
  const GLenum FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE             = 0x8216;
  const GLenum FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE           = 0x8217;
  const GLenum FRAMEBUFFER_DEFAULT                           = 0x8218;
  const GLenum DEPTH_STENCIL_ATTACHMENT                      = 0x821A;
  const GLenum DEPTH_STENCIL                                 = 0x84F9;
  const GLenum UNSIGNED_INT_24_8                             = 0x84FA;
  const GLenum DEPTH24_STENCIL8                              = 0x88F0;
  const GLenum UNSIGNED_NORMALIZED                           = 0x8C17;
  const GLenum DRAW_FRAMEBUFFER_BINDING                      = 0x8CA6; /* Same as FRAMEBUFFER_BINDING */
  const GLenum READ_FRAMEBUFFER                              = 0x8CA8;
  const GLenum DRAW_FRAMEBUFFER                              = 0x8CA9;
  const GLenum READ_FRAMEBUFFER_BINDING                      = 0x8CAA;
  const GLenum RENDERBUFFER_SAMPLES                          = 0x8CAB;
  const GLenum FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER          = 0x8CD4;
  const GLenum MAX_COLOR_ATTACHMENTS                         = 0x8CDF;
  const GLenum COLOR_ATTACHMENT1                             = 0x8CE1;
  const GLenum COLOR_ATTACHMENT2                             = 0x8CE2;
  const GLenum COLOR_ATTACHMENT3                             = 0x8CE3;
  const GLenum COLOR_ATTACHMENT4                             = 0x8CE4;
  const GLenum COLOR_ATTACHMENT5                             = 0x8CE5;
  const GLenum COLOR_ATTACHMENT6                             = 0x8CE6;
  const GLenum COLOR_ATTACHMENT7                             = 0x8CE7;
  const GLenum COLOR_ATTACHMENT8                             = 0x8CE8;
  const GLenum COLOR_ATTACHMENT9                             = 0x8CE9;
  const GLenum COLOR_ATTACHMENT10                            = 0x8CEA;
  const GLenum COLOR_ATTACHMENT11                            = 0x8CEB;
  const GLenum COLOR_ATTACHMENT12                            = 0x8CEC;
  const GLenum COLOR_ATTACHMENT13                            = 0x8CED;
  const GLenum COLOR_ATTACHMENT14                            = 0x8CEE;
  const GLenum COLOR_ATTACHMENT15                            = 0x8CEF;
  const GLenum FRAMEBUFFER_INCOMPLETE_MULTISAMPLE            = 0x8D56;
  const GLenum MAX_SAMPLES                                   = 0x8D57;
  const GLenum HALF_FLOAT                                    = 0x140B;
  const GLenum RG                                            = 0x8227;
  const GLenum RG_INTEGER                                    = 0x8228;
  const GLenum R8                                            = 0x8229;
  const GLenum RG8                                           = 0x822B;
  const GLenum R16F                                          = 0x822D;
  const GLenum R32F                                          = 0x822E;
  const GLenum RG16F                                         = 0x822F;
  const GLenum RG32F                                         = 0x8230;
  const GLenum R8I                                           = 0x8231;
  const GLenum R8UI                                          = 0x8232;
  const GLenum R16I                                          = 0x8233;
  const GLenum R16UI                                         = 0x8234;
  const GLenum R32I                                          = 0x8235;
  const GLenum R32UI                                         = 0x8236;
  const GLenum RG8I                                          = 0x8237;
  const GLenum RG8UI                                         = 0x8238;
  const GLenum RG16I                                         = 0x8239;
  const GLenum RG16UI                                        = 0x823A;
  const GLenum RG32I                                         = 0x823B;
  const GLenum RG32UI                                        = 0x823C;
  const GLenum VERTEX_ARRAY_BINDING                          = 0x85B5;
  const GLenum R8_SNORM                                      = 0x8F94;
  const GLenum RG8_SNORM                                     = 0x8F95;
  const GLenum RGB8_SNORM                                    = 0x8F96;
  const GLenum RGBA8_SNORM                                   = 0x8F97;
  const GLenum SIGNED_NORMALIZED                             = 0x8F9C;
  const GLenum COPY_READ_BUFFER                              = 0x8F36;
  const GLenum COPY_WRITE_BUFFER                             = 0x8F37;
  const GLenum COPY_READ_BUFFER_BINDING                      = 0x8F36; /* Same as COPY_READ_BUFFER */
  const GLenum COPY_WRITE_BUFFER_BINDING                     = 0x8F37; /* Same as COPY_WRITE_BUFFER */
  const GLenum UNIFORM_BUFFER                                = 0x8A11;
  const GLenum UNIFORM_BUFFER_BINDING                        = 0x8A28;
  const GLenum UNIFORM_BUFFER_START                          = 0x8A29;
  const GLenum UNIFORM_BUFFER_SIZE                           = 0x8A2A;
  const GLenum MAX_VERTEX_UNIFORM_BLOCKS                     = 0x8A2B;
  const GLenum MAX_FRAGMENT_UNIFORM_BLOCKS                   = 0x8A2D;
  const GLenum MAX_COMBINED_UNIFORM_BLOCKS                   = 0x8A2E;
  const GLenum MAX_UNIFORM_BUFFER_BINDINGS                   = 0x8A2F;
  const GLenum MAX_UNIFORM_BLOCK_SIZE                        = 0x8A30;
  const GLenum MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS        = 0x8A31;
  const GLenum MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS      = 0x8A33;
  const GLenum UNIFORM_BUFFER_OFFSET_ALIGNMENT               = 0x8A34;
  const GLenum ACTIVE_UNIFORM_BLOCKS                         = 0x8A36;
  const GLenum UNIFORM_TYPE                                  = 0x8A37;
  const GLenum UNIFORM_SIZE                                  = 0x8A38;
  const GLenum UNIFORM_BLOCK_INDEX                           = 0x8A3A;
  const GLenum UNIFORM_OFFSET                                = 0x8A3B;
  const GLenum UNIFORM_ARRAY_STRIDE                          = 0x8A3C;
  const GLenum UNIFORM_MATRIX_STRIDE                         = 0x8A3D;
  const GLenum UNIFORM_IS_ROW_MAJOR                          = 0x8A3E;
  const GLenum UNIFORM_BLOCK_BINDING                         = 0x8A3F;
  const GLenum UNIFORM_BLOCK_DATA_SIZE                       = 0x8A40;
  const GLenum UNIFORM_BLOCK_ACTIVE_UNIFORMS                 = 0x8A42;
  const GLenum UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES          = 0x8A43;
  const GLenum UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER     = 0x8A44;
  const GLenum UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER   = 0x8A46;
  const GLenum INVALID_INDEX                                 = 0xFFFFFFFF;
  const GLenum MAX_VERTEX_OUTPUT_COMPONENTS                  = 0x9122;
  const GLenum MAX_FRAGMENT_INPUT_COMPONENTS                 = 0x9125;
  const GLenum MAX_SERVER_WAIT_TIMEOUT                       = 0x9111;
  const GLenum OBJECT_TYPE                                   = 0x9112;
  const GLenum SYNC_CONDITION                                = 0x9113;
  const GLenum SYNC_STATUS                                   = 0x9114;
  const GLenum SYNC_FLAGS                                    = 0x9115;
  const GLenum SYNC_FENCE                                    = 0x9116;
  const GLenum SYNC_GPU_COMMANDS_COMPLETE                    = 0x9117;
  const GLenum UNSIGNALED                                    = 0x9118;
  const GLenum SIGNALED                                      = 0x9119;
  const GLenum ALREADY_SIGNALED                              = 0x911A;
  const GLenum TIMEOUT_EXPIRED                               = 0x911B;
  const GLenum CONDITION_SATISFIED                           = 0x911C;
  const GLenum WAIT_FAILED                                   = 0x911D;
  const GLenum SYNC_FLUSH_COMMANDS_BIT                       = 0x00000001;
  const GLenum VERTEX_ATTRIB_ARRAY_DIVISOR                   = 0x88FE;
  const GLenum ANY_SAMPLES_PASSED                            = 0x8C2F;
  const GLenum ANY_SAMPLES_PASSED_CONSERVATIVE               = 0x8D6A;
  const GLenum SAMPLER_BINDING                               = 0x8919;
  const GLenum RGB10_A2UI                                    = 0x906F;
  const GLenum INT_2_10_10_10_REV                            = 0x8D9F;
  const GLenum TRANSFORM_FEEDBACK                            = 0x8E22;
  const GLenum TRANSFORM_FEEDBACK_PAUSED                     = 0x8E23;
  const GLenum TRANSFORM_FEEDBACK_ACTIVE                     = 0x8E24;
  const GLenum TRANSFORM_FEEDBACK_BINDING                    = 0x8E25;
  const GLenum TEXTURE_IMMUTABLE_FORMAT                      = 0x912F;
  const GLenum MAX_ELEMENT_INDEX                             = 0x8D6B;
  const GLenum TEXTURE_IMMUTABLE_LEVELS                      = 0x82DF;

  const GLint64 TIMEOUT_IGNORED                              = -1;

  /* WebGL-specific enums */
  const GLenum MAX_CLIENT_WAIT_TIMEOUT_WEBGL                 = 0x9247;

  /* Buffer objects */
  // WebGL1:
  void bufferData(GLenum target, GLsizeiptr size, GLenum usage);
  void bufferData(GLenum target, [AllowShared] BufferSource? srcData, GLenum usage);
  void bufferSubData(GLenum target, GLintptr dstByteOffset, [AllowShared] BufferSource srcData);
  // WebGL2:
  void bufferData(GLenum target, [AllowShared] ArrayBufferView srcData, GLenum usage, GLuint srcOffset,
                  optional GLuint length = 0);
  void bufferSubData(GLenum target, GLintptr dstByteOffset, [AllowShared] ArrayBufferView srcData,
                     GLuint srcOffset, optional GLuint length = 0);

  void copyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset,
                         GLintptr writeOffset, GLsizeiptr size);
  // MapBufferRange, in particular its read-only and write-only modes,
  // can not be exposed safely to JavaScript. GetBufferSubData
  // replaces it for the purpose of fetching data back from the GPU.
  void getBufferSubData(GLenum target, GLintptr srcByteOffset, [AllowShared] ArrayBufferView dstBuffer,
                        optional GLuint dstOffset = 0, optional GLuint length = 0);

  /* Framebuffer objects */
  void blitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0,
                       GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
  void framebufferTextureLayer(GLenum target, GLenum attachment, WebGLTexture? texture, GLint level,
                               GLint layer);
  void invalidateFramebuffer(GLenum target, sequence&lt;GLenum&gt; attachments);
  void invalidateSubFramebuffer(GLenum target, sequence&lt;GLenum&gt; attachments,
                                GLint x, GLint y, GLsizei width, GLsizei height);
  void readBuffer(GLenum src);

  /* Renderbuffer objects */
  any getInternalformatParameter(GLenum target, GLenum internalformat, GLenum pname);
  void renderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat,
                                      GLsizei width, GLsizei height);

  /* Texture objects */
  void texStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width,
                    GLsizei height);
  void texStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width,
                    GLsizei height, GLsizei depth);

  // WebGL1 legacy entrypoints:
  void texImage2D(GLenum target, GLint level, GLint internalformat,
                  GLsizei width, GLsizei height, GLint border, GLenum format,
                  GLenum type, [AllowShared] ArrayBufferView? pixels);
  void texImage2D(GLenum target, GLint level, GLint internalformat,
                  GLenum format, GLenum type, TexImageSource source); // May throw DOMException

  void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset,
                     GLsizei width, GLsizei height,
                     GLenum format, GLenum type, [AllowShared] ArrayBufferView? pixels);
  void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset,
                     GLenum format, GLenum type, TexImageSource source); // May throw DOMException

  // WebGL2 entrypoints:
  void texImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height,
                  GLint border, GLenum format, GLenum type, GLintptr pboOffset);
  void texImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height,
                  GLint border, GLenum format, GLenum type,
                  TexImageSource source); // May throw DOMException
  void texImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height,
                  GLint border, GLenum format, GLenum type, [AllowShared] ArrayBufferView srcData,
                  GLuint srcOffset);

  void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height,
                  GLsizei depth, GLint border, GLenum format, GLenum type, GLintptr pboOffset);
  void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height,
                  GLsizei depth, GLint border, GLenum format, GLenum type,
                  TexImageSource source); // May throw DOMException
  void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height,
                  GLsizei depth, GLint border, GLenum format, GLenum type, [AllowShared] ArrayBufferView? srcData);
  void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height,
                  GLsizei depth, GLint border, GLenum format, GLenum type, [AllowShared] ArrayBufferView srcData,
                  GLuint srcOffset);

  void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width,
                     GLsizei height, GLenum format, GLenum type, GLintptr pboOffset);
  void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width,
                     GLsizei height, GLenum format, GLenum type,
                     TexImageSource source); // May throw DOMException
  void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width,
                     GLsizei height, GLenum format, GLenum type, [AllowShared] ArrayBufferView srcData,
                     GLuint srcOffset);

  void texSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset,
                     GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type,
                     GLintptr pboOffset);
  void texSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset,
                     GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type,
                     TexImageSource source); // May throw DOMException
  void texSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset,
                     GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type,
                     [AllowShared] ArrayBufferView? srcData, optional GLuint srcOffset = 0);

  void copyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset,
                         GLint x, GLint y, GLsizei width, GLsizei height);

  void compressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width,
                            GLsizei height, GLint border, GLsizei imageSize, GLintptr offset);
  void compressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width,
                            GLsizei height, GLint border, [AllowShared] ArrayBufferView srcData,
                            optional GLuint srcOffset = 0, optional GLuint srcLengthOverride = 0);

  void compressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width,
                            GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, GLintptr offset);
  void compressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width,
                            GLsizei height, GLsizei depth, GLint border, [AllowShared] ArrayBufferView srcData,
                            optional GLuint srcOffset = 0, optional GLuint srcLengthOverride = 0);

  void compressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset,
                               GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, GLintptr offset);
  void compressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset,
                               GLsizei width, GLsizei height, GLenum format,
                               [AllowShared] ArrayBufferView srcData,
                               optional GLuint srcOffset = 0,
                               optional GLuint srcLengthOverride = 0);

  void compressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset,
                               GLint zoffset, GLsizei width, GLsizei height, GLsizei depth,
                               GLenum format, GLsizei imageSize, GLintptr offset);
  void compressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset,
                               GLint zoffset, GLsizei width, GLsizei height, GLsizei depth,
                               GLenum format, [AllowShared] ArrayBufferView srcData,
                               optional GLuint srcOffset = 0,
                               optional GLuint srcLengthOverride = 0);

  /* Programs and shaders */
  [WebGLHandlesContextLoss] GLint getFragDataLocation(WebGLProgram program, DOMString name);

  /* Uniforms */
  void uniform1ui(WebGLUniformLocation? location, GLuint v0);
  void uniform2ui(WebGLUniformLocation? location, GLuint v0, GLuint v1);
  void uniform3ui(WebGLUniformLocation? location, GLuint v0, GLuint v1, GLuint v2);
  void uniform4ui(WebGLUniformLocation? location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);

  void uniform1fv(WebGLUniformLocation? location, Float32List data, optional GLuint srcOffset = 0,
                  optional GLuint srcLength = 0);
  void uniform2fv(WebGLUniformLocation? location, Float32List data, optional GLuint srcOffset = 0,
                  optional GLuint srcLength = 0);
  void uniform3fv(WebGLUniformLocation? location, Float32List data, optional GLuint srcOffset = 0,
                  optional GLuint srcLength = 0);
  void uniform4fv(WebGLUniformLocation? location, Float32List data, optional GLuint srcOffset = 0,
                  optional GLuint srcLength = 0);

  void uniform1iv(WebGLUniformLocation? location, Int32List data, optional GLuint srcOffset = 0,
                  optional GLuint srcLength = 0);
  void uniform2iv(WebGLUniformLocation? location, Int32List data, optional GLuint srcOffset = 0,
                  optional GLuint srcLength = 0);
  void uniform3iv(WebGLUniformLocation? location, Int32List data, optional GLuint srcOffset = 0,
                  optional GLuint srcLength = 0);
  void uniform4iv(WebGLUniformLocation? location, Int32List data, optional GLuint srcOffset = 0,
                  optional GLuint srcLength = 0);

  void uniform1uiv(WebGLUniformLocation? location, Uint32List data, optional GLuint srcOffset = 0,
                  optional GLuint srcLength = 0);
  void uniform2uiv(WebGLUniformLocation? location, Uint32List data, optional GLuint srcOffset = 0,
                  optional GLuint srcLength = 0);
  void uniform3uiv(WebGLUniformLocation? location, Uint32List data, optional GLuint srcOffset = 0,
                  optional GLuint srcLength = 0);
  void uniform4uiv(WebGLUniformLocation? location, Uint32List data, optional GLuint srcOffset = 0,
                  optional GLuint srcLength = 0);

  void uniformMatrix2fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data,
                        optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
  void uniformMatrix3x2fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data,
                          optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
  void uniformMatrix4x2fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data,
                          optional GLuint srcOffset = 0, optional GLuint srcLength = 0);

  void uniformMatrix2x3fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data,
                          optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
  void uniformMatrix3fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data,
                        optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
  void uniformMatrix4x3fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data,
                          optional GLuint srcOffset = 0, optional GLuint srcLength = 0);

  void uniformMatrix2x4fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data,
                          optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
  void uniformMatrix3x4fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data,
                          optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
  void uniformMatrix4fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data,
                        optional GLuint srcOffset = 0, optional GLuint srcLength = 0);

  /* Vertex attribs */
  void vertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w);
  void vertexAttribI4iv(GLuint index, Int32List values);
  void vertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
  void vertexAttribI4uiv(GLuint index, Uint32List values);
  void vertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);

  /* Writing to the drawing buffer */
  void vertexAttribDivisor(GLuint index, GLuint divisor);
  void drawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instanceCount);
  void drawElementsInstanced(GLenum mode, GLsizei count, GLenum type, GLintptr offset, GLsizei instanceCount);
  void drawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLintptr offset);

  /* Reading back pixels */
  // WebGL1:
  void readPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type,
                  [AllowShared] ArrayBufferView? dstData);
  // WebGL2:
  void readPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type,
                  GLintptr offset);
  void readPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type,
                  [AllowShared] ArrayBufferView dstData, GLuint dstOffset);

  /* Multiple Render Targets */
  void drawBuffers(sequence&lt;GLenum&gt; buffers);

  void clearBufferfv(GLenum buffer, GLint drawbuffer, Float32List values,
                     optional GLuint srcOffset = 0);
  void clearBufferiv(GLenum buffer, GLint drawbuffer, Int32List values,
                     optional GLuint srcOffset = 0);
  void clearBufferuiv(GLenum buffer, GLint drawbuffer, Uint32List values,
                      optional GLuint srcOffset = 0);

  void clearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);

  /* Query Objects */
  WebGLQuery? createQuery();
  void deleteQuery(WebGLQuery? query);
  [WebGLHandlesContextLoss] GLboolean isQuery(WebGLQuery? query);
  void beginQuery(GLenum target, WebGLQuery query);
  void endQuery(GLenum target);
  WebGLQuery? getQuery(GLenum target, GLenum pname);
  any getQueryParameter(WebGLQuery query, GLenum pname);

  /* Sampler Objects */
  WebGLSampler? createSampler();
  void deleteSampler(WebGLSampler? sampler);
  [WebGLHandlesContextLoss] GLboolean isSampler(WebGLSampler? sampler);
  void bindSampler(GLuint unit, WebGLSampler? sampler);
  void samplerParameteri(WebGLSampler sampler, GLenum pname, GLint param);
  void samplerParameterf(WebGLSampler sampler, GLenum pname, GLfloat param);
  any getSamplerParameter(WebGLSampler sampler, GLenum pname);

  /* Sync objects */
  WebGLSync? fenceSync(GLenum condition, GLbitfield flags);
  [WebGLHandlesContextLoss] GLboolean isSync(WebGLSync? sync);
  void deleteSync(WebGLSync? sync);
  GLenum clientWaitSync(WebGLSync sync, GLbitfield flags, GLuint64 timeout);
  void waitSync(WebGLSync sync, GLbitfield flags, GLint64 timeout);
  any getSyncParameter(WebGLSync sync, GLenum pname);

  /* Transform Feedback */
  WebGLTransformFeedback? createTransformFeedback();
  void deleteTransformFeedback(WebGLTransformFeedback? tf);
  [WebGLHandlesContextLoss] GLboolean isTransformFeedback(WebGLTransformFeedback? tf);
  void bindTransformFeedback (GLenum target, WebGLTransformFeedback? tf);
  void beginTransformFeedback(GLenum primitiveMode);
  void endTransformFeedback();
  void transformFeedbackVaryings(WebGLProgram program, sequence&lt;DOMString&gt; varyings, GLenum bufferMode);
  WebGLActiveInfo? getTransformFeedbackVarying(WebGLProgram program, GLuint index);
  void pauseTransformFeedback();
  void resumeTransformFeedback();

  /* Uniform Buffer Objects and Transform Feedback Buffers */
  void bindBufferBase(GLenum target, GLuint index, WebGLBuffer? buffer);
  void bindBufferRange(GLenum target, GLuint index, WebGLBuffer? buffer, GLintptr offset, GLsizeiptr size);
  any getIndexedParameter(GLenum target, GLuint index);
  sequence&lt;GLuint&gt;? getUniformIndices(WebGLProgram program, sequence&lt;DOMString&gt; uniformNames);
  any getActiveUniforms(WebGLProgram program, sequence&lt;GLuint&gt; uniformIndices, GLenum pname);
  GLuint getUniformBlockIndex(WebGLProgram program, DOMString uniformBlockName);
  any getActiveUniformBlockParameter(WebGLProgram program, GLuint uniformBlockIndex, GLenum pname);
  DOMString? getActiveUniformBlockName(WebGLProgram program, GLuint uniformBlockIndex);
  void uniformBlockBinding(WebGLProgram program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);

  /* Vertex Array Objects */
  WebGLVertexArrayObject? createVertexArray();
  void deleteVertexArray(WebGLVertexArrayObject? vertexArray);
  [WebGLHandlesContextLoss] GLboolean isVertexArray(WebGLVertexArrayObject? vertexArray);
  void bindVertexArray(WebGLVertexArrayObject? array);
};

interface <dfn id="WebGL2RenderingContext">WebGL2RenderingContext</dfn>
{
};
WebGL2RenderingContext includes WebGLRenderingContextBase;
WebGL2RenderingContext includes WebGL2RenderingContextBase;

</pre>

<!-- ======================================================================================================= -->

    <h4>More binding points</h4>

    <dl class="methods">
      <dt class="idl-code">void bindBuffer(GLenum target, WebGLBuffer? buffer)
          <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.9.1">OpenGL ES 3.0.4 &sect;2.9.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glBindBuffer.xhtml">man page</a>)</span>
      </dt>
      <dd>
          Binds the given WebGLBuffer object to the given binding point(target). <em>target</em> is given in the following table:
          <table>
              <tr><th>target</th></tr>
              <tr><td>ARRAY_BUFFER</td></tr>
              <tr><td>COPY_READ_BUFFER</td></tr>
              <tr><td>COPY_WRITE_BUFFER</td></tr>
              <tr><td>ELEMENT_ARRAY_BUFFER</td></tr>
              <tr><td>PIXEL_PACK_BUFFER</td></tr>
              <tr><td>PIXEL_UNPACK_BUFFER</td></tr>
              <tr><td>TRANSFORM_FEEDBACK_BUFFER</td></tr>
              <tr><td>UNIFORM_BUFFER</td></tr>
          </table>
          <p>If <em>target</em> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>
      </dd>
      <div class="note rationale">
          Refer to <a href="#BUFFER_OBJECT_BINDING">Buffer Object Binding</a> restrictions below.
      </div>

      <dt class="idl-code">void bindFramebuffer(GLenum target, WebGLFramebuffer? framebuffer)
          <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-4.4.1">OpenGL ES 3.0.4 &sect;4.4.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glBindFramebuffer.xhtml">man page</a>)</span>
      </dt>
      <dd>
          Binds the given WebGLFramebuffer object to the given binding point(target). <em>target</em> is given in the following table:
          <table>
              <tr><th>target</th></tr>
              <tr><td>FRAMEBUFFER</td></tr>
              <tr><td>READ_FRAMEBUFFER</td></tr>
              <tr><td>DRAW_FRAMEBUFFER</td></tr>
          </table>
          <p>If <em>target</em> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>
      </dd>

      <dt class="idl-code">void bindTexture(GLenum target, WebGLTexture? texture)
          <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.1">OpenGL ES 3.0.4 &sect;3.8.1</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glBindTexture.xhtml">man page</a>)</span>
      </dt>
      <dd>
          Binds the given WebGLTexture object to the given binding point(target). <em>target</em> is given in the following table:
          <table>
              <tr><th>target</th></tr>
              <tr><td>TEXTURE_2D</td></tr>
              <tr><td>TEXTURE_3D</td></tr>
              <tr><td>TEXTURE_2D_ARRAY</td></tr>
              <tr><td>TEXTURE_CUBE_MAP</td></tr>
          </table>
          <p>If <em>target</em> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>
      </dd>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Setting and getting state</h4>

    <dl class="methods">
        <dt class="idl-code"><a name="GETPARAMETER">any getParameter</a>(GLenum pname)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-6.1.1">OpenGL ES 3.0.4 &sect;6.1.1</a>,
            <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glGet.xhtml">glGet OpenGL ES 3.0 man page</a>,
            <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glGetString.xhtml">glGetString OpenGL ES 3.0 man page</a>)</span>
        <dd>
            Return the value for the passed pname. As well as supporting all
            the pname/type values from WebGL 1.0, the following parameters are supported:
            <table>
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>COPY_READ_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>COPY_WRITE_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>DRAW_BUFFER<em>i</em></td><td>GLenum</td></tr>
                <tr><td>DRAW_FRAMEBUFFER_BINDING</td><td>WebGLFramebuffer</td></tr>
                <tr><td>FRAGMENT_SHADER_DERIVATIVE_HINT</td><td>GLenum</td></tr>
                <tr><td>MAX_3D_TEXTURE_SIZE</td><td>GLint</td></tr>
                <tr><td>MAX_ARRAY_TEXTURE_LAYERS</td><td>GLint</td></tr>
                <tr><td>MAX_CLIENT_WAIT_TIMEOUT_WEBGL</td><td>GLint64</td></tr>
                <tr><td>MAX_COLOR_ATTACHMENTS</td><td>GLint</td></tr>
                <tr><td>MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS</td><td>GLint64</td></tr>
                <tr><td>MAX_COMBINED_UNIFORM_BLOCKS</td><td>GLint</td></tr>
                <tr><td>MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS</td><td>GLint64</td></tr>
                <tr><td>MAX_DRAW_BUFFERS</td><td>GLint</td></tr>
                <tr><td>MAX_ELEMENT_INDEX</td><td>GLint64</td></tr>
                <tr><td>MAX_ELEMENTS_INDICES</td><td>GLint</td></tr>
                <tr><td>MAX_ELEMENTS_VERTICES</td><td>GLint</td></tr>
                <tr><td>MAX_FRAGMENT_INPUT_COMPONENTS</td><td>GLint</td></tr>
                <tr><td>MAX_FRAGMENT_UNIFORM_BLOCKS</td><td>GLint</td></tr>
                <tr><td>MAX_FRAGMENT_UNIFORM_COMPONENTS</td><td>GLint</td></tr>
                <tr><td>MAX_PROGRAM_TEXEL_OFFSET</td><td>GLint</td></tr>
                <tr><td>MAX_SAMPLES</td><td>GLint</td></tr>
                <tr><td>MAX_SERVER_WAIT_TIMEOUT</td><td>GLint64</td></tr>
                <tr><td>MAX_TEXTURE_LOD_BIAS</td><td>GLfloat</td></tr>
                <tr><td>MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS</td><td>GLint</td></tr>
                <tr><td>MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS</td><td>GLint</td></tr>
                <tr><td>MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS</td><td>GLint</td></tr>
                <tr><td>MAX_UNIFORM_BLOCK_SIZE</td><td>GLint64</td></tr>
                <tr><td>MAX_UNIFORM_BUFFER_BINDINGS</td><td>GLint</td></tr>
                <tr><td>MAX_VARYING_COMPONENTS</td><td>GLint</td></tr>
                <tr><td>MAX_VERTEX_OUTPUT_COMPONENTS</td><td>GLint</td></tr>
                <tr><td>MAX_VERTEX_UNIFORM_BLOCKS</td><td>GLint</td></tr>
                <tr><td>MAX_VERTEX_UNIFORM_COMPONENTS</td><td>GLint</td></tr>
                <tr><td>MIN_PROGRAM_TEXEL_OFFSET</td><td>GLint</td></tr>
                <tr><td>PACK_ROW_LENGTH</td><td>GLint</td></tr>
                <tr><td>PACK_SKIP_PIXELS</td><td>GLint</td></tr>
                <tr><td>PACK_SKIP_ROWS</td><td>GLint</td></tr>
                <tr><td>PIXEL_PACK_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>PIXEL_UNPACK_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>RASTERIZER_DISCARD</td><td>GLboolean</td></tr>
                <tr><td>READ_BUFFER</td><td>GLenum</td></tr>
                <tr><td>READ_FRAMEBUFFER_BINDING</td><td>WebGLFramebuffer</td></tr>
                <tr><td>SAMPLER_BINDING</td><td>WebGLSampler</td></tr>
                <tr><td>TEXTURE_BINDING_2D_ARRAY</td><td>WebGLTexture</td></tr>
                <tr><td>TEXTURE_BINDING_3D</td><td>WebGLTexture</td></tr>
                <tr><td>TRANSFORM_FEEDBACK_ACTIVE</td><td>GLboolean</td></tr>
                <tr><td>TRANSFORM_FEEDBACK_BINDING</td><td>WebGLTransformFeedback</td></tr>
                <tr><td>TRANSFORM_FEEDBACK_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>TRANSFORM_FEEDBACK_PAUSED</td><td>GLboolean</td></tr>
                <tr><td>UNIFORM_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>UNIFORM_BUFFER_OFFSET_ALIGNMENT</td><td>GLint</td></tr>
                <tr><td>UNPACK_IMAGE_HEIGHT</td><td>GLint</td></tr>
                <tr><td>UNPACK_ROW_LENGTH</td><td>GLint</td></tr>
                <tr><td>UNPACK_SKIP_IMAGES</td><td>GLint</td></tr>
                <tr><td>UNPACK_SKIP_PIXELS</td><td>GLint</td></tr>
                <tr><td>UNPACK_SKIP_ROWS</td><td>GLint</td></tr>
                <tr><td>VERTEX_ARRAY_BINDING</td><td>WebGLVertexArrayObject</td></tr>
            </table><br>
            <p>All queries returning sequences or typed arrays return a new object each time.</p>
            <p>If <em>pname</em> is not in the table above and is not one of parameter names supported by WebGL 1.0, generates an <code>INVALID_ENUM</code> error and returns null.</p>
            <p>The following <em>pname</em> arguments return a string describing some aspect of the current WebGL implementation:</p>
            <table>
              <tr><td>VERSION</td>
                  <td>Returns a version or release number of the form <code>WebGL&lt;space&gt;2.0&lt;optional&gt;&lt;space&gt;&lt;vendor-specific information&gt;&lt;/optional&gt;</code>.</td></tr>
              <tr><td>SHADING_LANGUAGE_VERSION</td>
                  <td>Returns a version or release number of the form <code>WebGL&lt;space&gt;GLSL&lt;space&gt;ES&lt;space&gt;3.00&lt;optional&gt;&lt;space&gt;&lt;vendor-specific information&gt;&lt;/optional&gt;</code>.</td></tr>
            </table><br>
            <p>For <code>RED_BITS</code>, <code>GREEN_BITS</code>, <code>BLUE_BITS</code>, and <code>ALPHA_BITS</code>, if active color attachments of the draw framebuffer do not have identical formats, generates an <code>INVALID_OPERATION</code> error and returns 0.</p>

        <dt class="idl-code">any getIndexedParameter(GLenum target, GLuint index)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-6.1.1">OpenGL ES 3.0.4 &sect;6.1.1</a>,
            <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glGet.xhtml">glGet OpenGL ES 3.0 man page</a>)</span>
        <dd>
            Return the indexed value for the passed <code class="param">target</code>. The type returned is the natural type for the requested <code class="param">pname</code>,
            as given in the following table:
            <table class="foo">
                <tr><th>target</th><th>returned type</th></tr>
                <tr><td>TRANSFORM_FEEDBACK_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>TRANSFORM_FEEDBACK_BUFFER_SIZE</td><td>GLsizeiptr</td></tr>
                <tr><td>TRANSFORM_FEEDBACK_BUFFER_START</td><td>GLintptr</td></tr>
                <tr><td>UNIFORM_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>UNIFORM_BUFFER_SIZE</td><td>GLsizeiptr</td></tr>
                <tr><td>UNIFORM_BUFFER_START</td><td>GLintptr</td></tr>
            </table><br>
            <p>If <code class="param">target</code> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>
            <p>If <code class="param">index</code> is outside of the valid range for the indexed state <code class="param">target</code>, generates an <code>INVALID_VALUE</code> error.</p>
            <p>If an OpenGL error is generated, returns null.</p>
        <dt class="idl-code"><a name="ISENABLED">GLboolean isEnabled</a>(GLenum cap)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-6.1.1">OpenGL ES 3.0.4 &sect;6.1.1</a>,
            <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glIsEnabled.xhtml">OpenGL ES 3.0 man page</a>)</span>
        <dd>
            In addition to all of the <code class="param">cap</code> values from WebGL 1.0, RASTERIZER_DISCARD is supported.
        <dt class="idl-code">void pixelStorei(GLenum pname, GLint param)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.7.1">OpenGL ES 3.0.4 &sect;3.7.1</a>, <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glPixelStorei.xhtml">OpenGL ES 3.0 man page</a>)</span>
        <dd>
            In addition to the parameters from WebGL 1.0, the WebGL 2.0 specification accepts the following extra parameters:
            <table class="foo">
                <tr><th>pname</th></tr>
                <tr><td>PACK_ROW_LENGTH</td></tr>
                <tr><td>PACK_SKIP_PIXELS</td></tr>
                <tr><td>PACK_SKIP_ROWS</td></tr>
                <tr><td>UNPACK_ROW_LENGTH</td></tr>
                <tr><td>UNPACK_IMAGE_HEIGHT</td></tr>
                <tr><td>UNPACK_SKIP_PIXELS</td></tr>
                <tr><td>UNPACK_SKIP_ROWS</td></tr>
                <tr><td>UNPACK_SKIP_IMAGES</td></tr>
            </table><br>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Buffer objects</h4>

    <dl class="methods">

      <dt class="idl-code">void bufferData(GLenum target, [AllowShared] ArrayBufferView srcData, GLenum usage, GLuint srcOffset, optional GLuint length = 0);
          <span class="gl-spec">
          (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.10.2">OpenGL ES 3.0.4 &sect;2.10.2</a>,
           <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glBufferData.xhtml" class="nonnormative">man page</a>)
          </span>
      </dt>
      <dd>
        Set the size of the currently bound WebGLBuffer object, then copy a sub-region of <code>srcData</code> to the buffer object.
        <br><br>
        Let <code>buf</code> be the buffer bound to <code>target</code>.
        <br><br>
        If <code>length</code> is 0:
        <ul>
        <li> If <code>srcData</code> is a <code>DataView</code>, let <code>copyLength</code> be <code>srcData.byteLength - srcOffset</code>; the typed elements in the text below are bytes.
        <li> Otherwise, let <code>copyLength</code> be <code>srcData.length - srcOffset</code>.
        </ul>
        Otherwise, let <code>copyLength</code> be <code>length</code>.
        <br><br>
        If <code>srcData</code> is a <code>DataView</code>, set the size of <code>buf</code> to <code>copyLength</code>; otherwise, set the size of <code>buf</code> to <code>copyLength * srcData.BYTES_PER_ELEMENT</code>.
        <br><br>
        If <code>srcData</code> is a <code>DataView</code>, let <code>elementSize</code> be 1; otherwise, let <code>elementSize</code> be <code>srcData.BYTES_PER_ELEMENT</code>.
        <br><br>
        If <code>copyLength</code> is greater than zero, copy <code>copyLength</code> typed elements
        (each of size <code>elementSize</code>) from <code>srcData</code> into <code>buf</code>,
        reading <code>srcData</code> starting at element index <code>srcOffset</code>.
        If <code>copyLength</code> is 0, no data is written to <code>buf</code>, but this does
        not cause a GL error to be generated.
        <ul>
          <li> If no WebGLBuffer is bound to <code>target</code>, generates an <code>INVALID_OPERATION</code> error.
          <li> If <code>srcOffset</code> is greater than <code>srcData.length</code> (or <code>srcData.byteLength</code> for <code>DataView</code>), generates an <code>INVALID_VALUE</code> error.
          <li> If <code>srcOffset + copyLength</code> is greater than <code>srcData.length</code> (or <code>srcData.byteLength</code> for <code>DataView</code>), generates an <code>INVALID_VALUE</code> error.
        </ul>
        If any error is generated, <code>buf</code>'s size is unmodified, and no data is written to it.
      </dd>

      <dt class="idl-code">void bufferSubData(GLenum target, GLintptr dstByteOffset, [AllowShared] ArrayBufferView srcData, GLuint srcOffset, optional GLuint length = 0);
          <span class="gl-spec">
          (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.10.2">OpenGL ES 3.0.4 &sect;2.10.2</a>,
           <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glBufferSubData.xhtml" class="nonnormative">man page</a>)
          </span>
      </dt>
      <dd>
        Copy a sub-region of <code>srcData</code> to the currently bound WebGLBuffer object.
        <br><br>
        Let <code>buf</code> be the buffer bound to <code>target</code>.
        <br><br>
        If <code>length</code> is 0:
        <ul>
        <li> If <code>srcData</code> is a <code>DataView</code>, let <code>copyLength</code> be <code>srcData.byteLength - srcOffset</code>; the typed elements in the text below are bytes.
        <li> Otherwise, let <code>copyLength</code> be <code>srcData.length - srcOffset</code>.
        </ul>
        Otherwise, let <code>copyLength</code> be <code>length</code>.
        <br><br>
        If <code>srcData</code> is a <code>DataView</code>, let <code>copyByteLength</code> be <code>copyLength</code>; otherwise, let <code>copyByteLength</code> be <code>copyLength * srcData.BYTES_PER_ELEMENT</code>.
        <br><br>
        If <code>srcData</code> is a <code>DataView</code>, let <code>elementSize</code> be 1; otherwise, let <code>elementSize</code> be <code>srcData.BYTES_PER_ELEMENT</code>.
        <br><br>
        If <code>copyLength</code> is greater than zero, copy <code>copyLength</code> typed elements
        (each of size <code>elementSize</code>) from <code>srcData</code> into <code>buf</code>,
        reading <code>srcData</code> starting at element index <code>srcOffset</code>, and
        writing <code>buf</code> starting at byte offset <code>dstByteOffset</code>.
        If <code>copyLength</code> is 0, no data is written to <code>buf</code>, but this does
        not cause a GL error to be generated.
        <ul>
          <li> If no WebGLBuffer is bound to <code>target</code>, generates an <code>INVALID_OPERATION</code> error.
          <li> If <code>dstByteOffset</code> is less than zero, generates an <code>INVALID_VALUE</code> error.
          <li> If <code>dstByteOffset + copyByteLength</code> is greater than the size of <code>buf</code>, generates an <code>INVALID_VALUE</code> error.
          <li> If <code>srcOffset</code> is greater than <code>srcData.length</code> (or <code>srcData.byteLength</code> for <code>DataView</code>), generates an <code>INVALID_VALUE</code> error.
          <li> If <code>srcOffset + copyLength</code> is greater than <code>srcData.length</code> (or <code>srcData.byteLength</code> for <code>DataView</code>), generates an <code>INVALID_VALUE</code> error.
        </ul>
        If any error is generated, no data is written to <code>buf</code>.
      </dd>


      <dt class="idl-code">any getBufferParameter(GLenum target, GLenum pname)
          <span class="gl-spec">
          (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-6.1.9">OpenGL ES 3.0.4 &sect;6.1.9</a>,
          <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glGetBufferParameter.xhtml" class="nonnormative">man page</a>)
          </span>
      </dt>
      <dd>
        Return the value for the passed pname. In addition to supporting querying with the pname BUFFER_USAGE
        as in WebGL 1.0, querying with the pname BUFFER_SIZE returns the buffer size as a value of type
        GLsizeiptr.
      </dd>
      <dt>
        <p class="idl-code">void copyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.9.5">OpenGL ES 3.0.4 &sect;2.9.5</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glCopyBufferSubData.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Copy part of the data of the buffer bound to <em>readTarget</em> to the buffer bound to <em>writeTarget</em>.
        See <a href="#COPYING_BUFFERS">Copying Buffers</a> for restrictions imposed by the WebGL 2.0 API.
      </dd>
      <dt>
        <p class="idl-code">
          void getBufferSubData(GLenum target, GLintptr srcByteOffset,
                                [AllowShared] ArrayBufferView dstBuffer,
                                optional GLuint dstOffset = 0,
                                optional GLuint length = 0)
        </p>
      </dt>
      <dd>
        Reads back data from the bound WebGLBuffer into <code>dstBuffer</code>.
        <br><br>
        Let <code>buf</code> be the buffer bound to <code>target</code>.
        <br><br>
        If <code>length</code> is 0:
        <ul>
          <li> If <code>dstBuffer</code> is a <code>DataView</code>, let <code>copyLength</code> be <code>dstBuffer.byteLength - dstOffset</code>; the typed elements in the text below are bytes.
          <li> Otherwise, let <code>copyLength</code> be <code>dstBuffer.length - dstOffset</code>.
        </ul>
        Otherwise, let <code>copyLength</code> be <code>length</code>.
        <br><br>
        If <code>dstBuffer</code> is a <code>DataView</code>, let <code>copyByteLength</code> be <code>copyLength</code>; otherwise, let <code>copyByteLength</code> be <code>copyLength * dstBuffer.BYTES_PER_ELEMENT</code>.
        <br><br>
        If <code>dstBuffer</code> is a <code>DataView</code>, let <code>elementSize</code> be 1; otherwise, let <code>elementSize</code> be <code>dstBuffer.BYTES_PER_ELEMENT</code>.
        <br><br>
        If <code>copyLength</code> is greater than zero,
        copy <code>copyLength</code> typed elements (each of size <code>elementSize</code>)
        from <code>buf</code> into <code>dstBuffer</code>,
        reading <code>buf</code> starting at byte index <code>srcByteOffset</code> and
        writing into <code>dstBuffer</code> starting at element index <code>dstOffset</code>.
        If <code>copyLength</code> is 0, no data is written to <code>dstBuffer</code>, but
        this does not cause a GL error to be generated.
        <ul>
          <li>If no WebGLBuffer is bound to <code>target</code>,
              generates an <code>INVALID_OPERATION</code> error.
          <li>If <code>target</code> is <code>TRANSFORM_FEEDBACK_BUFFER</code>,
              and any transform feedback object is currently active,
              generates an <code>INVALID_OPERATION</code> error.
          <li>If <code>dstOffset</code> is greater than <code>dstBuffer.length</code>
              (or <code>dstBuffer.byteLength</code> in the case of <code>DataView</code>), generates
              an <code>INVALID_VALUE</code> error.
          <li>If <code>dstOffset + copyLength</code> is greater than <code>dstBuffer.length</code>
              (or <code>dstBuffer.byteLength</code> in the case of <code>DataView</code>), generates
              an <code>INVALID_VALUE</code> error.
          <li>If <code>srcByteOffset</code> is less than zero,
              generates an <code>INVALID_VALUE</code> error.
          <li>If <code>srcByteOffset + copyByteLength</code> is greater than the size
              of <code>buf</code>, generates an <code>INVALID_OPERATION</code> error.
        </ul>
        If any error is generated, no data is written to <code>dstBuffer</code>.
        <br><br>
        If the buffer is written and read sequentially by other operations and <code>getBufferSubData</code>,
        it is the responsibility of the WebGL API to ensure that data are accessed consistently. This applies
        even if the buffer is currently bound to a transform feedback binding point.
      </dd>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Framebuffer objects</h4>

    <dl class="methods">
      <dt class="idl-code">[WebGLHandlesContextLoss] GLenum checkFramebufferStatus(GLenum target)
          <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-4.4.5">OpenGL ES 3.0.4 &sect;4.4.4</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glCheckFramebufferStatus.xhtml">man page</a>)</span>
      <dd>
        <p>Only differences from <a href="../1.0/index.html#CHECK_FRAMEBUFFER_STATUS">checkFramebufferStatus</a> in WebGL 1.0 are described here.</p>
        <p><em>target</em> must be <code>DRAW_FRAMEBUFFER</code>, <code>READ_FRAMEBUFFER</code> or <code>FRAMEBUFFER</code>. <code>FRAMEBUFFER</code> is equivalent to <code>DRAW_FRAMEBUFFER</code>.</p>
        <p>Returns <code>FRAMEBUFFER_UNSUPPORTED</code> if depth and stencil attachments, if present, are not the same image. See <a href="#FBO_ATTACHMENTS">Framebuffer Object Attachments</a> for detailed discussion.</p>
        <p>Returns <code>FRAMEBUFFER_INCOMPLETE_MULTISAMPLE</code> if the values of <code>RENDERBUFFER_SAMPLES</code> are different among attached renderbuffers, or are non-zero if the attached images are a mix of renderbuffers and textures.</p>
        <p>Returns <code>FRAMEBUFFER_INCOMPLETE_DIMENSIONS</code> if attached images have different width, height, and depth (for 3D textures) or array size (for 2D array textures). See <a href="#INCOMPLETE_DIMENSIONS">checkFramebufferStatus may return FRAMEBUFFER_INCOMPLETE_DIMENSIONS</a>.</p>
        <p>Returns <code>FRAMEBUFFER_UNSUPPORTED</code> if the same image is attached to more than one color
        attachment point. See <a href="#FRAMEBUFFER_COLOR_ATTACHMENTS">Framebuffer color attachments</a>.</p>
      </dd>

      <dt class="idl-code">any getFramebufferAttachmentParameter(GLenum target, GLenum attachment, GLenum pname)
          <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-6.1.13">OpenGL ES 3.0.4 &sect;6.1.13</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glGetFramebufferAttachmentParameteriv.xhtml">glGetFramebufferAttachmentParameteriv</a>)</span>
      </dt>
      <dd>
          Return the value for the passed pname given the passed target and attachment. The type
          returned is the natural type for the requested pname, as given in the following table:
          <table>
              <tr><th>pname</th><th>returned type</th></tr>
              <tr><td>FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE</td><td>GLint</td></tr>
              <tr><td>FRAMEBUFFER_ATTACHMENT_BLUE_SIZE</td><td>GLint</td></tr>
              <tr><td>FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING</td><td>GLenum</td></tr>
              <tr><td>FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE</td><td>GLenum</td></tr>
              <tr><td>FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE</td><td>GLint</td></tr>
              <tr><td>FRAMEBUFFER_ATTACHMENT_GREEN_SIZE</td><td>GLint</td></tr>
              <tr><td>FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</td><td>WebGLRenderbuffer or WebGLTexture</td></tr>
              <tr><td>FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</td><td>GLenum</td></tr>
              <tr><td>FRAMEBUFFER_ATTACHMENT_RED_SIZE</td><td>GLint</td></tr>
              <tr><td>FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE</td><td>GLint</td></tr>
              <tr><td>FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</td><td>GLint</td></tr>
              <tr><td>FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER</td><td>GLint</td></tr>
              <tr><td>FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</td><td>GLint</td></tr>
          </table>
          <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>
          <p>If an OpenGL error is generated, returns null.</p>
          <p>If <em>attachment</em> is <code>DEPTH_STENCIL_ATTACHMENT</code> and different images are attached to the depth and stencil attachment points, generates an <code>INVALID_OPERATION</code> error. See <a href="#FBO_ATTACHMENTS">Framebuffer Object Attachments</a> for detailed discussion.</p>
      </dd>
      <dt>
        <p class="idl-code">void blitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-4.3.3">OpenGL ES 3.0.4 &sect;4.3.3</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glBlitFramebuffer.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Transfer a rectangle of pixel values from one region of the read framebuffer to another in the draw
        framebuffer. If the value of SAMPLE_BUFFERS for the read framebuffer is one and the value of
        SAMPLE_BUFFERS for the draw framebuffer is zero, the samples corresponding to each pixel location in
        the source are converted to a single sample before being written to the destination.<br><br>

        For any source pixel lying outside the read framebuffer, the corresponding destination pixel remains
        untouched.<br><br>

        When blitting to the color attachment of the WebGL context's default back buffer, a context
        created with <code>alpha:false</code> is considered to have internal
        format <code>RGB8</code>, while a context created with <code>alpha:true</code> is considered
        to have internal format <code>RGBA8</code>.<br><br>

        If this function attempts to blit to a missing attachment of a complete framebuffer, nothing is
        blitted to that attachment and no error is generated
        per <a href="../1.0/index.html#DRAWING_TO_MISSING_ATTACHMENT">Drawing to a Missing Attachment</a>.<br>

        If this function attempts to read from a missing attachment of a complete framebuffer, and at least one
        draw buffer has an image to be blitted, an <code>INVALID_OPERATION</code> error is generated
        per <a href="../1.0/index.html#READING_FROM_MISSING_ATTACHMENT">Reading from a Missing Attachment</a>.
      </dd>
      <dt>
        <p class="idl-code">void framebufferTextureLayer(GLenum target, GLenum attachment, WebGLTexture? texture, GLint level, GLint layer)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-4.4.2">OpenGL ES 3.0.4 &sect;4.4.2</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glFramebufferTextureLayer.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dt>
        <p class="idl-code">void invalidateFramebuffer(GLenum target, sequence&lt;GLenum&gt; attachments)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-4.5">OpenGL ES 3.0.4 &sect;4.5</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glInvalidateFramebuffer.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Equivalent to calling <code>invalidateSubFramebuffer</code> with <code>x</code> and <code>y</code>
        set to 0 and <code>width</code> and <code>height</code> set to the largest framebuffer object's
        attachments' width and height.
      </dd>
      <dt>
        <p class="idl-code">void invalidateSubFramebuffer (GLenum target, sequence&lt;GLenum&gt; attachments, GLint x, GLint y, GLsizei width, GLsizei height)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-4.5">OpenGL ES 3.0.4 &sect;4.5</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glInvalidateSubFramebuffer.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Signal the GL that it need not preserve all contents of a bound framebuffer object.
      </dd>
      <dt>
        <p class="idl-code">void readBuffer(GLenum src)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-4.3.1">OpenGL ES 3.0.4 &sect;4.3.1</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glReadBuffer.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Specify a color buffer of the read framebuffer as the read buffer.
      </dd>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Renderbuffer objects</h4>

    <dl class="methods">
      <dt>
        <p class="idl-code">any getInternalformatParameter(GLenum target, GLenum internalformat, GLenum pname)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-6.1.15">OpenGL ES 3.0.4 &sect;6.1.15</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glGetInternalformativ.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
          Return the value for the passed pname given the passed target and internalformat. The type
          returned is given in the following table:
          <table>
              <tr><th>pname</th><th>returned type</th></tr>
              <tr><td>SAMPLES</td><td>Int32Array</td></tr>
          </table>
          <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>
          <p>If an OpenGL error is generated, returns null.</p>
          <p>Each query for SAMPLES returns a new typed array object instance.</p>
      </dd>
      <dt class="idl-code">any getRenderbufferParameter(GLenum target, GLenum pname)
          <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-6.1.14">OpenGL ES 2.0 &sect;6.1.14</a>, similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glGetRenderbufferParameteriv.xhtml">glGetRenderbufferParameteriv</a>)</span>
      </dt>
      <dd>
          Return the value for the passed pname given the passed target. The type returned is the natural
          type for the requested pname, as given in the following table:
          <table>
              <tr><th>pname</th><th>returned type</th></tr>
              <tr><td>RENDERBUFFER_WIDTH</td><td>GLint</td></tr>
              <tr><td>RENDERBUFFER_HEIGHT</td><td>GLint</td></tr>
              <tr><td>RENDERBUFFER_INTERNAL_FORMAT</td><td>GLenum</td></tr>
              <tr><td>RENDERBUFFER_RED_SIZE</td><td>GLint</td></tr>
              <tr><td>RENDERBUFFER_GREEN_SIZE</td><td>GLint</td></tr>
              <tr><td>RENDERBUFFER_BLUE_SIZE</td><td>GLint</td></tr>
              <tr><td>RENDERBUFFER_ALPHA_SIZE</td><td>GLint</td></tr>
              <tr><td>RENDERBUFFER_DEPTH_SIZE</td><td>GLint</td></tr>
              <tr><td>RENDERBUFFER_SAMPLES</td><td>GLint</td></tr>
              <tr><td>RENDERBUFFER_STENCIL_SIZE</td><td>GLint</td></tr>
          </table>
          <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>
          <p>If an OpenGL error is generated, returns null.</p>
      </dd>
      <dt>
        <p class="idl-code">void renderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-4.4.2">OpenGL ES 3.0.4 &sect;4.4.2</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glRenderbufferStorage.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        <p>Accepts internal formats from OpenGL ES 3.0 as detailed in the <a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-4.4.2">specification</a> and <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glRenderbufferStorage.xhtml" class="nonnormative">man page</a>.</p>
        <p>To be backward compatible with WebGL 1, also accepts internal format <code>DEPTH_STENCIL</code>, which should be mapped to <code>DEPTH24_STENCIL8</code> by implementations.</p>
      </dd>
      <dt>
        <p class="idl-code">void renderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-4.4.2">OpenGL ES 3.0.4 &sect;4.4.2</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glRenderbufferStorageMultisample.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Texture objects</h4>

    <p>
        Texture objects provide storage and state for texturing operations. If no WebGLTexture is bound
        (e.g., passing null or 0 to bindTexture) then attempts to modify or query the texture object shall
        generate an <code>INVALID_OPERATION</code> error. This is indicated in the functions below in cases
        where The OpenGL ES 3.0 specification allows the function to change the default texture.
    </p>

    <dl class="methods">
      <dt class="idl-code">any getTexParameter(GLenum target, GLenum pname)
          <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-6.1.3">OpenGL ES 3.0.4 &sect;6.1.3</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glGetTexParameter.xhtml">man page</a>)</span>
      </dt>
      <dd>
          Return the value for the passed pname given the passed target. The type returned is the natural type for the
          requested pname, as given in the following table:
          <table>
              <tr><th>pname</th><th>returned type</th></tr>
              <tr><td>TEXTURE_BASE_LEVEL</td><td>GLint</td></tr>
              <tr><td>TEXTURE_COMPARE_FUNC</td><td>GLenum</td></tr>
              <tr><td>TEXTURE_COMPARE_MODE</td><td>GLenum</td></tr>
              <tr><td>TEXTURE_IMMUTABLE_FORMAT</td><td>GLboolean</td></tr>
              <tr><td>TEXTURE_IMMUTABLE_LEVELS</td><td>GLuint</td></tr>
              <tr><td>TEXTURE_MAG_FILTER</td><td>GLenum</td></tr>
              <tr><td>TEXTURE_MAX_LEVEL</td><td>GLint</td></tr>
              <tr><td>TEXTURE_MAX_LOD</td><td>GLfloat</td></tr>
              <tr><td>TEXTURE_MIN_FILTER</td><td>GLenum</td></tr>
              <tr><td>TEXTURE_MIN_LOD</td><td>GLfloat</td></tr>
              <tr><td>TEXTURE_WRAP_R</td><td>GLenum</td></tr>
              <tr><td>TEXTURE_WRAP_S</td><td>GLenum</td></tr>
              <tr><td>TEXTURE_WRAP_T</td><td>GLenum</td></tr>
          </table>
          <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>
          <p>If an attempt is made to call this function with no WebGLTexture bound (see above), generates an
          <code>INVALID_OPERATION</code> error.</p>
          <p>If an OpenGL error is generated, returns null.</p>
      </dd>
      <dt class="idl-code">void texParameterf(GLenum target, GLenum pname, GLfloat param)
          <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.7">OpenGL ES 3.0.4 &sect;3.8.7</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glTexParameter.xhtml">man page</a>)</span>
      </dt>
      <dd>
          Set the value for the passed pname given the passed target. <em>pname</em> is given in the following table:
          <table>
              <tr><th>pname</th></tr>
              <tr><td>TEXTURE_BASE_LEVEL</td></tr>
              <tr><td>TEXTURE_COMPARE_FUNC</td></tr>
              <tr><td>TEXTURE_COMPARE_MODE</td></tr>
              <tr><td>TEXTURE_MAG_FILTER</td></tr>
              <tr><td>TEXTURE_MAX_LEVEL</td></tr>
              <tr><td>TEXTURE_MAX_LOD</td></tr>
              <tr><td>TEXTURE_MIN_FILTER</td></tr>
              <tr><td>TEXTURE_MIN_LOD</td></tr>
              <tr><td>TEXTURE_WRAP_R</td></tr>
              <tr><td>TEXTURE_WRAP_S</td></tr>
              <tr><td>TEXTURE_WRAP_T</td></tr>
          </table>
          <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>
          <p>If an attempt is made to call this function with no WebGLTexture bound (see above), generates an
          <code>INVALID_OPERATION</code> error.</p>
      </dd>
      <dt class="idl-code">void texParameteri(GLenum target, GLenum pname, GLint param)
          <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.7">OpenGL ES 3.0.4 &sect;3.8.7</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glTexParameter.xhtml">man page</a>)</span>
      </dt>
      <dd>
          <p>Set the value for the passed pname given the passed target. <em>pname</em> is this same with that of texParameterf, as given in the table above.</p>
          <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>
          <p>If an attempt is made to call this function with no WebGLTexture bound (see above), generates an
          <code>INVALID_OPERATION</code> error.</p>
      </dd>
      <dt>
        <p class="idl-code">void texStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.4">OpenGL ES 3.0.4 &sect;3.8.4</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glTexStorage2D.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Specify all the levels of a two-dimensional or cube-map texture at the same time. <br><br>

        The image contents are set as if a buffer of sufficient size initialized to 0 would be passed to
        each texImage2D call in the pseudocode in The OpenGL ES 3.0 specification section 3.8.4
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.4">OpenGL ES 3.0.4 &sect;3.8.4</a>)</span>.

        <div class="note"><code>texStorage2D</code> should be considered a preferred alternative to
        <code>texImage2D</code>. It may have lower memory costs than <code>texImage2D</code> in some
        implementations.</div>
      </dd>
      <dt>
        <p class="idl-code"><a name="TEXSTORAGE3D">void texStorage3D</a>(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.4">OpenGL ES 3.0.4 &sect;3.8.4</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glTexStorage3D.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Specify all the levels of a three-dimensional texture or two-dimensional array texture. <br><br>

        The image contents are set as if a buffer of sufficient size initialized to 0 would be passed to
        each texImage3D call in the pseudocode in The OpenGL ES 3.0 specification section 3.8.4
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.4">OpenGL ES 3.0.4 &sect;3.8.4</a>)</span>.
      </dd>

      <dt class="idl-code">
        void texImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width,
                        GLsizei height, GLint border, GLenum format, GLenum type,
                        [AllowShared] ArrayBufferView srcData, GLuint srcOffset)
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.3">OpenGL ES 3.0.4 &sect;3.8.4</a>, <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glTexImage2D.xhtml">man page</a>)</span>
      </dt>
      <dd>
        <p>Only differences from <a href="../1.0/index.html#TEXIMAGE2D">texImage2D</a> in WebGL 1.0 are described here. </p>
        <p>If a WebGLBuffer is bound to the <code>PIXEL_UNPACK_BUFFER</code> target, generates an <code>INVALID_OPERATION</code> error.</p>
        <p>Sized internal formats are supported in WebGL 2.0 and <em>internalformat</em> is no longer required to be the same as <em>format</em>. Instead, the combination of <em>internalformat</em>, <em>format</em>, and <em>type</em> must be listed in Table 1 or 2 from <span class="gl-spec"><a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glTexImage2D.xhtml">man page</a></span>.</p>
        <p>If <em>type</em> is specified as <code>FLOAT_32_UNSIGNED_INT_24_8_REV</code>,
           <em>srcData</em> must be null; otherwise, generates an <code>INVALID_OPERATION</code>
           error.
        <p>The type of <em>srcData</em> must match the <em>type</em> according to the following
           table; otherwise, generates an <code>INVALID_OPERATION</code> error:
        <table id="TEXTURE_PIXELS_TYPE_TABLE">
          <tr><th>type of <em>srcData</em></th><th><em>type</em></th></tr>
          <tr><td>Int8Array</td><td>BYTE</td></tr>
          <tr><td>Uint8Array</td><td>UNSIGNED_BYTE</td></tr>
          <tr><td>Int16Array</td><td>SHORT</td></tr>
          <tr><td>Uint16Array</td><td>UNSIGNED_SHORT</td></tr>
          <tr><td>Uint16Array</td><td>UNSIGNED_SHORT_5_6_5</td></tr>
          <tr><td>Uint16Array</td><td>UNSIGNED_SHORT_5_5_5_1</td></tr>
          <tr><td>Uint16Array</td><td>UNSIGNED_SHORT_4_4_4_4</td></tr>
          <tr><td>Int32Array</td><td>INT</td></tr>
          <tr><td>Uint32Array</td><td>UNSIGNED_INT</td></tr>
          <tr><td>Uint32Array</td><td>UNSIGNED_INT_5_9_9_9_REV</td></tr>
          <tr><td>Uint32Array</td><td>UNSIGNED_INT_2_10_10_10_REV</td></tr>
          <tr><td>Uint32Array</td><td>UNSIGNED_INT_10F_11F_11F_REV</td></tr>
          <tr><td>Uint32Array</td><td>UNSIGNED_INT_24_8</td></tr>
          <tr><td>Uint16Array</td><td>HALF_FLOAT</td></tr>
          <tr><td>Float32Array</td><td>FLOAT</td></tr>
        </table>
        <p>
            If <a href="#PIXEL_STORE_PARAM_CONSTRAINTS">pixel store parameter constraints</a> are not met,
            generates an <code>INVALID_OPERATION</code> error.
        </p>
        <p>Reading from <code>srcData</code> begins <code>srcOffset</code> elements into
           <code>srcData</code>. (Elements are bytes for Uint8Array, int32s for Int32Array, etc.)
        <p>If there's not enough data in <code>srcData</code> starting at <code>srcOffset</code>,
           generate INVALID_OPERATION.
      </dd>

      <dt class="idl-code">
        [throws]
        void texImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width,
                        GLsizei height, GLint border, GLenum format, GLenum type,
                        TexImageSource source) // May throw DOMException
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.3">OpenGL ES 3.0.4 &sect;3.8.4</a>, <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glTexImage2D.xhtml">man page</a>)</span>
      </dt>
      <dd>
        <p>Only differences from <a href="../1.0/index.html#TEXIMAGE2D_HTML">texImage2D</a> in WebGL 1.0 are described here. </p>
        <p>Uploading subregions of elements is detailed in <a href="#DOM_UPLOAD_UNPACK_PARAMS">Pixel
           store parameters for uploads from <code>TexImageSource</code></a>.
        <p>If a WebGLBuffer is bound to the <code>PIXEL_UNPACK_BUFFER</code> target, generates an <code>INVALID_OPERATION</code> error.</p>
        <p>Sized internal formats are supported in WebGL 2.0 and <em>internalformat</em> is no longer required to be the same as <em>format</em>. Instead, the combination of <em>internalformat</em>, <em>format</em>, and <em>type</em> must be listed in the following table:</p>
        <table id="TEXTURE_TYPES_FORMATS_FROM_DOM_ELEMENTS_TABLE">
        <tr><th>Internal Format</th><th>Format</th><th>Type</th></tr>
        <tr><td>RGB</td><td>RGB</td><td>UNSIGNED_BYTE<br>UNSIGNED_SHORT_5_6_5</td></tr>
        <tr><td>RGBA</td><td>RGBA</td><td>UNSIGNED_BYTE,<br>UNSIGNED_SHORT_4_4_4_4<br>UNSIGNED_SHORT_5_5_5_1</td></tr>
        <tr><td>LUMINANCE_ALPHA</td><td>LUMINANCE_ALPHA</td><td>UNSIGNED_BYTE</td></tr>
        <tr><td>LUMINANCE</td><td>LUMINANCE</td><td>UNSIGNED_BYTE</td></tr>
        <tr><td>ALPHA</td><td>ALPHA</td><td>UNSIGNED_BYTE</td></tr>
        <tr><td>R8</td><td>RED</td><td>UNSIGNED_BYTE</td></tr>
        <tr><td>R16F</td><td>RED</td><td>HALF_FLOAT<br>FLOAT</td></tr>
        <tr><td>R32F</td><td>RED</td><td>FLOAT</td></tr>
        <tr><td>R8UI</td><td>RED_INTEGER</td><td>UNSIGNED_BYTE</td></tr>
        <tr><td>RG8</td><td>RG</td><td>UNSIGNED_BYTE</td></tr>
        <tr><td>RG16F</td><td>RG</td><td>HALF_FLOAT<br>FLOAT</td></tr>
        <tr><td>RG32F</td><td>RG</td><td>FLOAT</td></tr>
        <tr><td>RG8UI</td><td>RG_INTEGER</td><td>UNSIGNED_BYTE</td></tr>
        <tr><td>RGB8</td><td>RGB</td><td>UNSIGNED_BYTE</td></tr>
        <tr><td>SRGB8</td><td>RGB</td><td>UNSIGNED_BYTE</td></tr>
        <tr><td>RGB565</td><td>RGB</td><td>UNSIGNED_BYTE<br>UNSIGNED_SHORT_5_6_5</td></tr>
        <tr><td>R11F_G11F_B10F</td><td>RGB</td><td>UNSIGNED_INT_10F_11F_11F_REV<br>HALF_FLOAT<br>FLOAT</td></tr>
        <tr><td>RGB9_E5</td><td>RGB</td><td>HALF_FLOAT<br>FLOAT</td></tr>
        <tr><td>RGB16F</td><td>RGB</td><td>HALF_FLOAT<br>FLOAT</td></tr>
        <tr><td>RGB32F</td><td>RGB</td><td>FLOAT</td></tr>
        <tr><td>RGB8UI</td><td>RGB_INTEGER</td><td>UNSIGNED_BYTE</td></tr>
        <tr><td>RGBA8</td><td>RGBA</td><td>UNSIGNED_BYTE</td></tr>
        <tr><td>SRGB8_ALPHA8</td><td>RGBA</td><td>UNSIGNED_BYTE</td></tr>
        <tr><td>RGB5_A1</td><td>RGBA</td><td>UNSIGNED_BYTE<br>UNSIGNED_SHORT_5_5_5_1</td></tr>
        <tr><td>RGB10_A2</td><td>RGBA</td><td>UNSIGNED_INT_2_10_10_10_REV</td></tr>
        <tr><td>RGBA4</td><td>RGBA</td><td>UNSIGNED_BYTE<br>UNSIGNED_SHORT_4_4_4_4</td></tr>
        <tr><td>RGBA16F</td><td>RGBA</td><td>HALF_FLOAT<br>FLOAT</td></tr>
        <tr><td>RGBA32F</td><td>RGBA</td><td>FLOAT</td></tr>
        <tr><td>RGBA8UI</td><td>RGBA_INTEGER</td><td>UNSIGNED_BYTE</td></tr>
        </table>
        <div class="note rationale">When the data source is a DOM element (<code>HTMLImageElement</code>, <code>HTMLCanvasElement</code>, or <code>HTMLVideoElement</code>), or is an <code>ImageBitmap</code> or <code>ImageData</code> object, commonly each channel's representation is an unsigned integer type of at least 8 bits. Converting such representation to signed integers or unsigned integers with more bits is not clearly defined. For example, when converting RGBA8 to RGBA16UI,  it is unclear whether or not the intention is to scale up values to the full range of a 16-bit unsigned integer. Therefore, only converting to unsigned integer of at most 8 bits, half float, or float is allowed.</div>
      </dd>

      <dt class="idl-code"><a name="TEXIMAGE2D_SERVER_SIDE">void texImage2D</a>(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, GLintptr offset) <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.3">OpenGL ES 3.0.4 &sect;3.8.4</a>, <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glTexImage2D.xhtml">man page</a>)</span>
      </dt>
      <dd>
        <p>Upload data to the currently bound WebGLTexture from the WebGLBuffer bound to the <code>PIXEL_UNPACK_BUFFER</code> target.</p>
        <p><em>offset</em> is the byte offset into the WebGLBuffer's data store; generates an <code>INVALID_VALUE</code> if it's less than 0.</p>
        <p>The combination of <em>format</em>, <em>type</em>, and WebGLTexture's internal format must be listed in Table 1 or 2 from <span class="gl-spec"><a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glTexImage2D.xhtml">man page</a></span>.</p>
        <p>If an attempt is made to call the function with no WebGLTexture bound, generates an <code>INVALID_OPERATION</code> error.</p>
        <p>If no WebGLBuffer is bound to the <code>PIXEL_UNPACK_BUFFER</code> target, generates an <code>INVALID_OPERATION</code> error.</p>
        <p>
            If <a href="#PIXEL_STORE_PARAM_CONSTRAINTS">pixel store parameter constraints</a> are not met,
            generates an <code>INVALID_OPERATION</code> error.
        </p>
      </dd>

      <dt class="idl-code"><a name="TEXSUBIMAGE2D">
        void texSubImage2D</a>(GLenum target, GLint level, GLint xoffset, GLint yoffset,
                               GLsizei width, GLsizei height, GLenum format, GLenum type,
                               [AllowShared] ArrayBufferView srcData, GLuint srcOffset)
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.5">OpenGL ES 3.0.4 &sect;3.8.5</a>, <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glTexSubImage2D.xhtml">man page</a>)</span>
      </dt>
      <dd>
        <p>Only differences from <a href="../1.0/index.html#TEXSUBIMAGE2D">texSubImage2D</a> in WebGL 1.0 are described here. </p>
        <p>If a WebGLBuffer is bound to the <code>PIXEL_UNPACK_BUFFER</code> target, generates an <code>INVALID_OPERATION</code> error.</p>
        <p>The combination of <em>format</em>, <em>type</em>, and WebGLTexture's internal format must be listed in Table 1 or 2 from <span class="gl-spec"><a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glTexImage2D.xhtml">man page</a></span>.</p>
        <p>The type of <em>srcData</em> must match the <em>type</em> according to the <a
           href="#TEXTURE_PIXELS_TYPE_TABLE"> above table</a>; otherwise, generates an
           <code>INVALID_OPERATION</code> error.</p>
        <p>See <a href="../1.0/index.html#PIXEL_STORAGE_PARAMETERS">Pixel Storage Parameters</a> for WebGL-specific pixel storage parameters that affect the behavior of this function.</p>
        <p>
            If <a href="#PIXEL_STORE_PARAM_CONSTRAINTS"> pixel store parameter constraints</a> are not met,
            generates an <code>INVALID_OPERATION</code> error.
        </p>
        <p>Reading from <code>srcData</code> begins <code>srcOffset</code> elements into
           <code>srcData</code>. (Elements are bytes for Uint8Array, int32s for Int32Array, etc.)
        <p>If there's not enough data in <code>srcData</code> starting at <code>srcOffset</code>,
           generate INVALID_OPERATION.
      </dd>


      <dt><p class="idl-code"><a name="TEXSUBIMAGE2D_HTML">
        void texSubImage2D</a>(GLenum target, GLint level, GLint xoffset, GLint yoffset,
                               GLsizei width, GLsizei height, GLenum format, GLenum type,
                               TexImageSource source) // May throw DOMException
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.5">OpenGL ES 3.0.4 &sect;3.8.5</a>, <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glTexSubImage2D.xhtml">man page</a>)</span>
      </dt>
      <dd>
        <p>Only differences from <a href="../1.0/index.html#TEXSUBIMAGE2D_HTML">texSubImage2D</a> in WebGL 1.0 are described here. </p>
        <p>Uploading subregions of elements is detailed in <a href="#DOM_UPLOAD_UNPACK_PARAMS">Pixel
           store parameters for uploads from <code>TexImageSource</code></a>.
        <p>If a WebGLBuffer is bound to the <code>PIXEL_UNPACK_BUFFER</code> target, generates an <code>INVALID_OPERATION</code> error.</p>
        <p>The combination of <em>format</em>, <em>type</em>, and WebGLTexture's internal format must be listed in <a href="#TEXTURE_TYPES_FORMATS_FROM_DOM_ELEMENTS_TABLE">this table</a>.</p>
      </dd>

      <dt><p class="idl-code"><a name="TEXSUBIMAGE2D_SERVER_SIDE">
        void texSubImage2D</a>(GLenum target, GLint level, GLint xoffset, GLint yoffset,
                               GLsizei width, GLsizei height, GLenum format, GLenum type,
                               GLintptr offset)
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.5">OpenGL ES 3.0.4 &sect;3.8.5</a>, <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glTexSubImage2D.xhtml">man page</a>)</span>
      </dt>
      <dd>
        <p>Updates a sub-rectangle of the currently bound WebGLTexture with data from the WebGLBuffer bound to <code>PIXEL_UNPACK_BUFFER</code> target.</p>
        <p><em>offset</em> is the byte offset into the WebGLBuffer's data store; generates an <code>INVALID_VALUE</code> error if it's less than 0.</p>
        <p>If an attempt is made to call the function with no WebGLTexture bound, generates an <code>INVALID_OPERATION</code> error.</p>
        <p>If no WebGLBuffer is bound to the <code>PIXEL_UNPACK_BUFFER</code> target, generates an <code>INVALID_OPERATION</code> error.</p>
        <p>
            If <a href="#PIXEL_STORE_PARAM_CONSTRAINTS"> pixel store parameter constraints</a> are not met,
            generates an <code>INVALID_OPERATION</code> error.
        </p>
      </dd>

      <dt class="idl-code">
        <p>void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width,
                           GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type,
                           [AllowShared] ArrayBufferView? srcData)</p>
        <p>void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width,
                           GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type,
                           [AllowShared] ArrayBufferView srcData, GLuint srcOffset)
          <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.3">OpenGL ES 3.0.4 &sect;3.8.4</a>, <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glTexImage3D.xhtml">man page</a>)</span>
        </p>
      </dt>
      <dd>
        <p>Allocates and initializes the specified mipmap level of a three-dimensional or two-dimensional array texture. </p>
        <p>If a WebGLBuffer is bound to the <code>PIXEL_UNPACK_BUFFER</code> target, generates an <code>INVALID_OPERATION</code> error.</p>
        <p>If <code>srcData</code> is null, a buffer of sufficient size initialized to 0 is passed. </p>
        <p>The combination of <em>internalformat</em>, <em>format</em>, and <em>type</em> must be listed in Table 1 or 2 from <span class="gl-spec"><a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glTexImage3D.xhtml">man page</a></span>.</p>
        <p>If <em>type</em> is specified as <code>FLOAT_32_UNSIGNED_INT_24_8_REV</code>,
           <em>srcData</em> must be null; otherwise, generates an <code>INVALID_OPERATION</code>
           error.
        <p>If <em>srcData</em> is non-null, the type of <em>srcData</em> must match the <em>type</em>
           according to the <a href="#TEXTURE_PIXELS_TYPE_TABLE">above table</a>; otherwise,
           generate an <code>INVALID_OPERATION</code> error.
        <p>If an attempt is made to call this function with no WebGLTexture bound (see above), generates an <code>INVALID_OPERATION</code> error.</p>
        <p>See <a href="../1.0/index.html#PIXEL_STORAGE_PARAMETERS">Pixel Storage Parameters</a> for WebGL-specific pixel storage parameters that affect the behavior of this function. </p>
        <p>
            If <a href="#PIXEL_STORE_PARAM_CONSTRAINTS"> pixel store parameter constraints</a> are not met,
            generates an <code>INVALID_OPERATION</code> error.
        </p>
        <p>Reading from <code>srcData</code> begins <code>srcOffset</code> elements into
           <code>srcData</code>. (Elements are bytes for Uint8Array, int32s for Int32Array, etc.)
        <p>If there's not enough data in <code>srcData</code> starting at <code>srcOffset</code>,
           generate INVALID_OPERATION.

        <div class="note">It is recommended to use <a href="#TEXSTORAGE3D">texStorage3D</a> instead of texImage3D to allocate three-dimensional textures. texImage3D may impose a higher memory cost compared to texStorage3D in some implementations.</div>
      </dd>

      <dt>
        <p class="idl-code">
          void texImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width,
                          GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type,
                          TexImageSource source) // May throw DOMException
          <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.3">OpenGL ES 3.0.4 &sect;3.8.4</a>, <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glTexImage3D.xhtml">man page</a>)</span>
        </p>
      </dt>
      <dd>
        <p>Update a rectangular subregion of the currently bound WebGLTexture. </p>
        <p>Uploading subregions of elements is detailed in <a href="#DOM_UPLOAD_UNPACK_PARAMS">Pixel
           store parameters for uploads from <code>TexImageSource</code></a>.
        <p>See <a href="../1.0/index.html#TEXIMAGE2D_HTML">texImage2D</a> for the interpretation of the <em>format</em> and <em>type</em> arguments, and notes on the <code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code> pixel storage parameter. </p>
        <p>See <a href="../1.0/index.html#PIXEL_STORAGE_PARAMETERS">Pixel Storage Parameters</a> for WebGL-specific pixel storage parameters that affect the behavior of this function when it is called with any argument type other than <code>ImageBitmap</code>.</p>
        <p>The first pixel transferred from the source to the WebGL implementation corresponds to the upper left corner of the source. This behavior is modified by the <code>UNPACK_FLIP_Y_WEBGL</code> <a href="../1.0/index.html#PIXEL_STORAGE_PARAMETERS">pixel storage parameter</a>, except for <code>ImageBitmap</code> arguments, as described in the abovementioned section. </p>
        <p>The combination of <em>format</em>, <em>type</em>, and WebGLTexture's internal format must be listed in <a href="#TEXTURE_TYPES_FORMATS_FROM_DOM_ELEMENTS_TABLE">this table</a>.</p>
        <p>If an attempt is made to call this function with no WebGLTexture bound (see above), generates an <code>INVALID_OPERATION</code> error.</p>
        <p>If a WebGLBuffer is bound to the <code>PIXEL_UNPACK_BUFFER</code> target, generates an <code>INVALID_OPERATION</code> error.</p>
        <p>If this function is called with an <code>ImageData</code> whose <code>data</code> attribute has been neutered, an <code>INVALID_VALUE</code> error is generated. </p>
        <p>If this function is called with an <code>ImageBitmap</code> that has been neutered, an <code>INVALID_VALUE</code> error is generated. </p>
        <p>If this function is called with an <code>HTMLImageElement</code> or <code>HTMLVideoElement</code> whose origin differs from the origin of the containing Document, or with an <code>HTMLCanvasElement</code> or <code>ImageBitmap</code> whose bitmap's <i>origin-clean</i> flag is set to false, a <code>SECURITY_ERR</code> exception must be thrown. See <a href="../1.0/index.html#ORIGIN_RESTRICTIONS">Origin Restrictions</a>.</p>
      </dd>

      <dt class="idl-code"><a name="TEXIMAGE3D_SERVER_SIDE">void texImage3D</a>(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, GLintptr offset)
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.3">OpenGL ES 3.0.4 &sect;3.8.4</a>, <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glTexImage3D.xhtml">man page</a>)</span>
      </dt>
      <dd>
        <p>Upload data to the currently bound WebGLTexture from the WebGLBuffer bound to the <code>PIXEL_UNPACK_BUFFER</code> target.</p>
        <p><em>offset</em> is the byte offset into the WebGLBuffer's data store; generates an <code>INVALID_VALUE</code> error if it's less than 0.</p>
        <p>If an attempt is made to call the function with no WebGLTexture bound, generates an <code>INVALID_OPERATION</code> error.</p>
        <p>If no WebGLBuffer is bound to the <code>PIXEL_UNPACK_BUFFER</code> target, generates an <code>INVALID_OPERATION</code> error.</p>
        <p>
            If <a href="#PIXEL_STORE_PARAM_CONSTRAINTS">pixel store parameter constraints</a> are not met,
            generates an <code>INVALID_OPERATION</code> error.
        </p>
      </dd>

      <dt>
        <p class="idl-code">
          void texSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset,
                             GLint zoffset, GLsizei width, GLsizei height, GLsizei depth,
                             GLenum format, GLenum type, [AllowShared] ArrayBufferView? srcData,
                             optional GLuint srcOffset = 0)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.5">OpenGL ES 3.0.4 &sect;3.8.5</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glTexSubImage3D.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        <p>Update a rectangular subregion of the currently bound WebGLTexture. </p>
        <p>If an attempt is made to call this function with no WebGLTexture bound (see above), generates an <code>INVALID_OPERATION</code> error. </p>
        <p>If a WebGLBuffer is bound to the <code>PIXEL_UNPACK_BUFFER</code> target, generates an <code>INVALID_OPERATION</code> error.</p>
        <p>The combination of <em>format</em>, <em>type</em>, and WebGLTexture's internal format must be listed in Table 1 or 2 from <span class="gl-spec"><a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glTexImage3D.xhtml">man page</a></span>.</p>
        <p>If <em>type</em> is <code>FLOAT_32_UNSIGNED_INT_24_8_REV</code>, generates an <code>INVALID_ENUM</code> error.</p>
        <p>The type of <em>srcData</em> must match the <em>type</em> according to the <a
           href="#TEXTURE_PIXELS_TYPE_TABLE">above table</a>; otherwise, generates an
           <code>INVALID_OPERATION</code> error.
        <p>If <code>srcData</code> is non-null but its size is less than what is required by the specified <em>width</em>, <em>height</em>, <em>depth</em>, <em>format</em>, <em>type</em>, and pixel storage parameters, generates an <code>INVALID_OPERATION</code> error. </p>
        <p>See <a href="../1.0/index.html#PIXEL_STORAGE_PARAMETERS">Pixel Storage Parameters</a> for WebGL-specific pixel storage parameters that affect the behavior of this function.</p>
        <p>
            If <a href="#PIXEL_STORE_PARAM_CONSTRAINTS"> pixel store parameter constraints</a> are not met,
            generates an <code>INVALID_OPERATION</code> error.
        </p>
        <p>Reading from <code>srcData</code> begins <code>srcOffset</code> elements into
           <code>srcData</code>. (Elements are bytes for Uint8Array, int32s for Int32Array, etc.)
        <p>If there's not enough data in <code>srcData</code> starting at <code>srcOffset</code>,
           generate INVALID_OPERATION.
      </dd>
      <dt>
        <p class="idl-code">
          void texSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset,
                             GLint zoffset, GLsizei width, GLsizei height, GLsizei depth,
                             GLenum format, GLenum type,
                             TexImageSource source) // May throw DOMException
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.5">OpenGL ES 3.0.4 &sect;3.8.5</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glTexSubImage3D.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        <p>Update a rectangular subregion of the currently bound WebGLTexture. </p>
        <p>Uploading subregions of elements is detailed in <a href="#DOM_UPLOAD_UNPACK_PARAMS">Pixel
           store parameters for uploads from <code>TexImageSource</code></a>.
        <p>See <a href="../1.0/index.html#TEXIMAGE2D_HTML">texImage2D</a> for the interpretation of the <em>format</em> and <em>type</em> arguments, and notes on the <code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code> pixel storage parameter. </p>
        <p>See <a href="../1.0/index.html#PIXEL_STORAGE_PARAMETERS">Pixel Storage Parameters</a> for WebGL-specific pixel storage parameters that affect the behavior of this function when it is called with any argument type other than <code>ImageBitmap</code>.</p>
        <p>The first pixel transferred from the source to the WebGL implementation corresponds to the upper left corner of the source. This behavior is modified by the <code>UNPACK_FLIP_Y_WEBGL</code> <a href="../1.0/index.html#PIXEL_STORAGE_PARAMETERS">pixel storage parameter</a>, except for <code>ImageBitmap</code> arguments, as described in the abovementioned section. </p>
        <p>The combination of <em>format</em>, <em>type</em>, and WebGLTexture's internal format must be listed in <a href="#TEXTURE_TYPES_FORMATS_FROM_DOM_ELEMENTS_TABLE">this table</a>.</p>
        <p>If an attempt is made to call this function with no WebGLTexture bound (see above), generates an <code>INVALID_OPERATION</code> error.</p>
        <p>If a WebGLBuffer is bound to the <code>PIXEL_UNPACK_BUFFER</code> target, generates an <code>INVALID_OPERATION</code> error.</p>
        <p>If this function is called with an <code>ImageData</code> whose <code>data</code> attribute has been neutered, an <code>INVALID_VALUE</code> error is generated. </p>
        <p>If this function is called with an <code>ImageBitmap</code> that has been neutered, an <code>INVALID_VALUE</code> error is generated. </p>
        <p>If this function is called with an <code>HTMLImageElement</code> or <code>HTMLVideoElement</code> whose origin differs from the origin of the containing Document, or with an <code>HTMLCanvasElement</code> or <code>ImageBitmap</code> whose bitmap's <i>origin-clean</i> flag is set to false, a <code>SECURITY_ERR</code> exception must be thrown. See <a href="../1.0/index.html#ORIGIN_RESTRICTIONS">Origin Restrictions</a>.</p>
      </dd>

      <dt>
        <p class="idl-code"><a name="TEXSUBIMAGE3D_SERVER_SIDE">void texSubImage3D</a>(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLintptr offset)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.5">OpenGL ES 3.0.4 &sect;3.8.5</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glTexSubImage3D.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        <p>Updates a sub-rectangle of the currently bound WebGLTexture with data from the WebGLBuffer bound to <code>PIXEL_UNPACK_BUFFER</code> target.</p>
        <p><em>offset</em> is the byte offset into the WebGLBuffer's data store; generates an <code>INVALID_VALUE</code> error if it's less than 0.</p>
        <p>If an attempt is made to call the function with no WebGLTexture bound, generates an <code>INVALID_OPERATION</code> error.</p>
        <p>If no WebGLBuffer is bound to the <code>PIXEL_UNPACK_BUFFER</code> target, generates an <code>INVALID_OPERATION</code> error.</p>
        <p>
            If <a href="#PIXEL_STORE_PARAM_CONSTRAINTS">pixel store parameter constraints</a> are not met,
            generates an <code>INVALID_OPERATION</code> error.
        </p>
      </dd>

      <dt>
        <p class="idl-code">void copyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.5">OpenGL ES 3.0.4 &sect;3.8.5</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glCopyTexSubImage3D.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        If an attempt is made to call this function with no WebGLTexture bound (see above), an
        <code>INVALID_OPERATION</code> error is generated. <br><br>

        For any pixel lying outside the framebuffer, the corresponding destination pixel remains
        untouched; see <a href="../1.0/index.html#READS_OUTSIDE_FRAMEBUFFER">Reading Pixels Outside
        the Framebuffer</a>. <br><br>

        If this function attempts to read from a missing attachment of a complete framebuffer,
        an <code>INVALID_OPERATION</code> error is generated
        per <a href="../1.0/index.html#READING_FROM_MISSING_ATTACHMENT">Reading from a Missing Attachment</a>.
      </dd>

      <dt>
        <p class="idl-code">
          void compressedTexImage2D(GLenum target, GLint level, GLenum internalformat,
                                    GLsizei width, GLsizei height, GLint border,
                                    [AllowShared] ArrayBufferView srcData,
                                    optional GLuint srcOffset = 0,
                                    optional GLuint srcLengthOverride = 0)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.6">OpenGL ES 3.0.4 &sect;3.8.6</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glCompressedTexImage2D.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      <dd>
        <p>Reading from <code>srcData</code> begins <code>srcOffset</code> elements into
           <code>srcData</code>. (Elements are bytes for Uint8Array, int32s for Int32Array, etc.)</p>
        <p>If <code>srcOffset</code> &gt; <code>srcData.length</code>, generates an INVALID_VALUE error.</p>
        <p><code>srcLengthOverride</code> defaults to <code>srcData.length - srcOffset</code>.</p>
        <p>If there's not enough data in <code>srcData</code> starting at <code>srcOffset</code>, or
           if the amount of data passed in is not consistent with the format, dimensions, and
           contents of the compressed image, generates an INVALID_VALUE error.</p>
      </dd>
      </dt>
      <dt>
        <p class="idl-code">
          void compressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset,
                                       GLsizei width, GLsizei height, GLenum format,
                                       [AllowShared] ArrayBufferView srcData,
                                       optional GLuint srcOffset = 0,
                                       optional GLuint srcLengthOverride = 0)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.6">OpenGL ES 3.0.4 &sect;3.8.6</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glCompressedTexSubImage2D.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      <dd>
        <p>Reading from <code>srcData</code> begins <code>srcOffset</code> elements into
           <code>srcData</code>. (Elements are bytes for Uint8Array, int32s for Int32Array, etc.)
        <p>If <code>srcOffset</code> &gt; <code>srcData.length</code>, generates an INVALID_VALUE error.</p>
        <p><code>srcLengthOverride</code> defaults to <code>srcData.length - srcOffset</code>.</p>
        <p>If there's not enough data in <code>srcData</code> starting at <code>srcOffset</code>, or
           if the amount of data passed in is not consistent with the format, dimensions, and
           contents of the compressed image, generates an INVALID_VALUE error.</p>
      </dd>
      </dt>

      <dt>
        <p class="idl-code">
          void compressedTexImage3D(GLenum target, GLint level, GLenum internalformat,
                                    GLsizei width, GLsizei height, GLsizei depth, GLint border,
                                    [AllowShared] ArrayBufferView srcData,
                                    optional GLuint srcOffset = 0,
                                    optional GLuint srcLengthOverride = 0)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.6">OpenGL ES 3.0.4 &sect;3.8.6</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glCompressedTexImage3D.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      <dd>
        <p>Reading from <code>srcData</code> begins <code>srcOffset</code> elements into
           <code>srcData</code>. (Elements are bytes for Uint8Array, int32s for Int32Array, etc.)
        <p>If <code>srcOffset</code> &gt; <code>srcData.length</code>, generates an INVALID_VALUE error.</p>
        <p><code>srcLengthOverride</code> defaults to <code>srcData.length - srcOffset</code>.</p>
        <p>If there's not enough data in <code>srcData</code> starting at <code>srcOffset</code>, or
           if the amount of data passed in is not consistent with the format, dimensions, and
           contents of the compressed image, generates an INVALID_VALUE error.</p>
      </dd>
      </dt>
      <dt>
        <p class="idl-code">
          void compressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset,
                                       GLint zoffset, GLsizei width, GLsizei height, GLsizei depth,
                                       GLenum format, [AllowShared] ArrayBufferView srcData,
                                       optional GLuint srcOffset = 0,
                                       optional GLuint srcLengthOverride = 0)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.6">OpenGL ES 3.0.4 &sect;3.8.6</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glCompressedTexSubImage3D.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      <dd>
        <p>Reading from <code>srcData</code> begins <code>srcOffset</code> elements into
           <code>srcData</code>. (Elements are bytes for Uint8Array, int32s for Int32Array, etc.)
        <p>If <code>srcOffset</code> &gt; <code>srcData.length</code>, generates an INVALID_VALUE error.</p>
        <p><code>srcLengthOverride</code> defaults to <code>srcData.length - srcOffset</code>.</p>
        <p>If there's not enough data in <code>srcData</code> starting at <code>srcOffset</code>, or
           if the amount of data passed in is not consistent with the format, dimensions, and
           contents of the compressed image, generates an INVALID_VALUE error.</p>
      </dd>
      </dt>
      <p><strong>This section applies to the above four entry points.</strong></p>
      <dd>
        <p>If an attempt is made to call these functions with no WebGLTexture bound (see above), generates an <code>INVALID_OPERATION</code> error.</p>
        <p>If a WebGLBuffer is bound to the <code>PIXEL_UNPACK_BUFFER</code> target, generates an <code>INVALID_OPERATION</code> error.</p>
        <p>The ETC2 and EAC texture formats defined in OpenGL ES 3.0 are <a href="#NO_ETC2_EAC">not available in WebGL 2.0</a>.
      </dd>

      <dt>
        <p class="idl-code">void compressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, GLintptr offset)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.6">OpenGL ES 3.0.4 &sect;3.8.6</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glCompressedTexImage2D.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dt>
        <p class="idl-code">void compressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, GLintptr offset)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.6">OpenGL ES 3.0.4 &sect;3.8.6</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glCompressedTexSubImage2D.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dt>
        <p class="idl-code">void compressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, GLintptr offset)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.6">OpenGL ES 3.0.4 &sect;3.8.6</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glCompressedTexImage3D.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dt>
        <p class="idl-code">void compressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, GLintptr offset)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.6">OpenGL ES 3.0.4 &sect;3.8.6</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glCompressedTexSubImage3D.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <p><strong>This section applies to the above four entry points.</strong></p>
      <dd>
        <p>If an attempt is made to call these functions with no WebGLTexture bound (see above), generates an <code>INVALID_OPERATION</code> error.</p>
        <p>If no WebGLBuffer is bound to the <code>PIXEL_UNPACK_BUFFER</code> target, generates an <code>INVALID_OPERATION</code> error.</p>
        <p><em>offset</em> is the byte offset into the WebGLBuffer's data store; generates an <code>INVALID_VALUE</code> error if it's less than 0.</p>
        <p>The ETC2 and EAC texture formats defined in OpenGL ES 3.0 are <a href="#NO_ETC2_EAC">not available in WebGL 2.0</a>.
      </dd>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Programs and Shaders</h4>

    <dl class="methods">
      <dt>
        <p class="idl-code">[WebGLHandlesContextLoss] GLint getFragDataLocation(WebGLProgram program, DOMString name)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.9.2">OpenGL ES 3.0.4 &sect;3.9.2</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glGetFragDataLocation.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dt class="idl-code">any getProgramParameter(WebGLProgram? program, GLenum pname)
          <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-6.1.12">OpenGL ES 3.0.4 &sect;6.1.12</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glGetProgramiv.xhtml">man page</a>)</span>
      </dt>
      <dd>
          Return the value for the passed pname given the passed program. The type returned is the natural
          type for the requested pname, as given in the following table:
          <table>
              <tr><th>pname</th><th>returned type</th></tr>
              <tr><td>DELETE_STATUS</td><td>GLboolean</td></tr>
              <tr><td>LINK_STATUS</td><td>GLboolean</td></tr>
              <tr><td>VALIDATE_STATUS</td><td>GLboolean</td></tr>
              <tr><td>ATTACHED_SHADERS</td><td>GLint</td></tr>
              <tr><td>ACTIVE_ATTRIBUTES</td><td>GLint</td></tr>
              <tr><td>ACTIVE_UNIFORMS</td><td>GLint</td></tr>
              <tr><td>TRANSFORM_FEEDBACK_BUFFER_MODE</td><td>GLenum</td></tr>
              <tr><td>TRANSFORM_FEEDBACK_VARYINGS</td><td>GLint</td></tr>
              <tr><td>ACTIVE_UNIFORM_BLOCKS</td><td>GLint</td></tr>
          </table>
          <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error and returns null.</p>
          <p>Returns null if any OpenGL errors are generated during the execution of this
          function.</p>
      </dd>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Uniforms and attributes</h4>

    <dl class="methods">
      <dt class="idl-code">
        any getUniform(WebGLProgram program, WebGLUniformLocation location)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-6.1.12">OpenGL ES 3.0.4 &sect;6.1.12</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glGetUniform.xhtml" class="nonnormative">man page</a>)
          </span>
      </dt>
      <dd>
        Return the uniform value at the passed location in the passed program. The type returned is dependent
        on the uniform type. The types returned for the new uniform types in WebGL 2.0 are given in the
        following table:
        <table>
          <tr><th>uniform type</th><th>returned type</th></tr>
          <tr><td>uint</td><td>GLuint</td></tr>
          <tr><td>uvec2</td><td>Uint32Array (with 2 elements)</td></tr>
          <tr><td>uvec3</td><td>Uint32Array (with 3 elements)</td></tr>
          <tr><td>uvec4</td><td>Uint32Array (with 4 elements)</td></tr>
          <tr><td>mat2x3</td><td>Float32Array (with 6 elements)</td></tr>
          <tr><td>mat2x4</td><td>Float32Array (with 8 elements)</td></tr>
          <tr><td>mat3x2</td><td>Float32Array (with 6 elements)</td></tr>
          <tr><td>mat3x4</td><td>Float32Array (with 12 elements)</td></tr>
          <tr><td>mat4x2</td><td>Float32Array (with 8 elements)</td></tr>
          <tr><td>mat4x3</td><td>Float32Array (with 12 elements)</td></tr>
          <tr><td>any sampler type</td><td>GLint</td></tr>
        </table><br>
        <p>The types returned for the uniform types shared with WebGL 1.0 are the same as in WebGL 1.0.</p>
      </dd>
      <dt>
        <p class="idl-code">void uniform[1234]ui(WebGLUniformLocation? location, ...)</p>
        <p class="idl-code">void uniform[1234]uiv(WebGLUniformLocation? location, ...)</p>
        <p class="idl-code">void uniformMatrix[234]x[234]fv(WebGLUniformLocation? location, ...)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.11.6">OpenGL ES 3.0.4 &sect;2.11.6</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Each of the uniform* functions above sets the specified uniform or uniforms to the values
        provided. If the passed <code>location</code> is not null and was not obtained from the
        currently used program via an earlier call to <code>getUniformLocation</code>,
        an <code>INVALID_OPERATION</code> error will be generated. If the passed
        <code>location</code> is null, the data passed in will be silently ignored and no uniform
        variables will be changed.
        <br><br>
        If the array passed to any of the vector forms (those ending in <code>v</code>) has an
        invalid length, an <code>INVALID_VALUE</code> error will be generated. The length is invalid
        if it is too short for or is not an integer multiple of the assigned type.
        <p>In overloads with a <code>srcLength</code> arg:
          <ul>
            <li>If <code>srcLength</code> is 0, it defaults to
                <code>data.length - srcOffset</code>.
            <li>If <code>srcOffset + srcLength</code> is longer than
                <code>data.length</code>, generate <code>INVALID_VALUE</code>.
          </ul>
        <p>
      </dd>
      <dt><p class="idl-code">void vertexAttribI4[u]i(GLuint index, ...)</p>
          <p class="idl-code">void vertexAttribI4[u]iv(GLuint index, ...)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.7">OpenGL ES 3.0.4 &sect;2.7</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glVertexAttrib.xhtml" class="nonnormative">man page</a>)
          </span>
      </dt>
      <dd>
        Sets the vertex attribute at the passed index to the given constant integer value. Values set via the
        <code>vertexAttrib</code> are guaranteed to be returned from the <code>getVertexAttrib</code> function
        with the <code>CURRENT_VERTEX_ATTRIB</code> param, even if there have been intervening calls to
        <code>drawArrays</code> or <code>drawElements</code>.
      </dd>
      <dt>
        <p class="idl-code">void vertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.8">OpenGL ES 3.0.4 &sect;2.8</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glVertexAttribPointer.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Assign the WebGLBuffer object currently bound to the ARRAY_BUFFER target to the vertex
        attribute at the passed index. Values are always left as integer values. Size is number of
        components per attribute. Stride and offset are in units of bytes. Passed stride and offset
        must be appropriate for the passed type and size or an <code>INVALID_OPERATION</code> error
        will be generated; see <a href="../1.0/index.html#BUFFER_OFFSET_AND_STRIDE">Buffer Offset and Stride
        Requirements</a>. If offset is negative, an <code>INVALID_VALUE</code> error will be
        generated. If no WebGLBuffer is bound to the ARRAY_BUFFER target,
        an <code>INVALID_OPERATION</code> error will be generated. In WebGL, the maximum supported
        stride is 255; see <a href="../1.0/index.html#VERTEX_STRIDE"> Vertex Attribute Data Stride</a>.
      </dd>
      <dt class="idl-code">any getVertexAttrib(GLuint index, GLenum pname)
          <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-6.1.12">OpenGL ES 3.0.4 &sect;6.1.12</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glGetVertexAttrib.xhtml">man page</a>)</span>
      </dt>
      <dd>
          Return the information requested in pname about the vertex attribute at the passed index. The
          type returned is dependent on the information requested, as shown in the following table:
          <table>
              <tr><th>pname</th><th>returned type</th></tr>
              <tr><td>VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
              <tr><td>VERTEX_ATTRIB_ARRAY_ENABLED</td><td>GLboolean</td></tr>
              <tr><td>VERTEX_ATTRIB_ARRAY_SIZE</td><td>GLint</td></tr>
              <tr><td>VERTEX_ATTRIB_ARRAY_STRIDE</td><td>GLint</td></tr>
              <tr><td>VERTEX_ATTRIB_ARRAY_TYPE</td><td>GLenum</td></tr>
              <tr><td>VERTEX_ATTRIB_ARRAY_NORMALIZED</td><td>GLboolean</td></tr>
              <tr><td>CURRENT_VERTEX_ATTRIB</td><td>One of Float32Array, Int32Array or Uint32Array (each with 4 elements)</td></tr>
              <tr><td>VERTEX_ATTRIB_ARRAY_INTEGER</td><td>GLboolean</td></tr>
              <tr><td>VERTEX_ATTRIB_ARRAY_DIVISOR</td><td>GLint</td></tr>
          </table>
          <p>For CURRENT_VERTEX_ATTRIB, the return type is dictated by the most recent call
            to the vertexAttrib family of functions for the given index. That is, if
            vertexAttribI4i* was used, the return type will be Int32Array; If vertexAttribI4ui*
            was used, the return type will be Uint32Array; Otherwise, Float32Array.
          </p>
          <p>All queries returning sequences or typed arrays return a new object each time.</p>
          <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>
          <p>If an OpenGL error is generated, returns null.</p>
      </dd>
    </dl>

<!-- ======================================================================================================= -->

    <h4><a name="WRITING_TO_THE_DRAWING_BUFFER">Writing to the drawing buffer</a></h4>

    <dl class="methods">
      <dt>
        <p class="idl-code">void clear(GLbitfield mask)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-4.2.3">OpenGL ES 3.0.4 &sect;4.2.3</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glClear.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Clear buffers to preset values. If an integer color buffer is among the buffers that would be
        cleared, an <code>INVALID_OPERATION</code> error is generated and nothing is cleared.
      </dd>
      <dt>
        <p class="idl-code">void vertexAttribDivisor(GLuint index, GLuint divisor)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.8">OpenGL ES 3.0.4 &sect;2.8</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glVertexAttribDivisor.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Set the rate at which the vertex attribute identified by <code>index</code> advances when drawing.
      </dd>
      <dt>
        <p class="idl-code">void drawArrays(GLenum mode, GLint first, GLsizei count)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.9.3">OpenGL ES 3.0.4 &sect;2.9.3</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glDrawArrays.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dt>
        <p class="idl-code">void drawElements(GLenum mode, GLsizei count, GLenum type, GLintptr offset)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.9.3">OpenGL ES 3.0.4 &sect;2.9.3</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glDrawElements.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dt>
        <p class="idl-code">void drawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instanceCount)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.9.3">OpenGL ES 3.0.4 &sect;2.9.3</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glDrawArraysInstanced.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Draw <code>instanceCount</code> instances of geometry using the currently enabled vertex attributes.
        Vertex attributes which have a non-zero divisor advance once every divisor instances.<br><br>
      </dd>
      <dt>
        <p class="idl-code">void drawElementsInstanced(GLenum mode, GLsizei count, GLenum type, GLintptr offset, GLsizei instanceCount)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.9.3">OpenGL ES 3.0.4 &sect;2.9.3</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glDrawElementsInstanced.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Draw <code>instanceCount</code> instances of geometry using the currently bound element array buffer.
        Vertex attributes which have a non-zero divisor advance once every divisor instances.<br><br>
      </dd>
      <dt>
        <p class="idl-code">void drawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLintptr offset)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.9.3">OpenGL ES 3.0.4 &sect;2.9.3</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glDrawRangeElements.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Draw using the currently bound element array buffer. All error conditions specified for
        <code>drawElements</code> in the section <a href="../1.0/index.html#WRITING_TO_THE_DRAWING_BUFFER">Writing
        to the drawing buffer</a> of the WebGL 1.0 specification apply.<br><br>

        In addition, if indices used to draw are outside the range of [<em>start</em>, <em>end</em>], an imeplementation
        can either guarantee the behaviors defined in <a href="../1.0/index.html#OUT_OF_RANGE_ARRAY_ACCESSES">Out-of-Range
        Array Accesses</a>, or simply discard the arguments <em>start</em> and <em>end</em> and call <code>drawElements</code>
        instead. In either situation, no GL errors should be generated for this cause.
      </dd>
    </dl>

    <p>
        During calls to <code>drawElements</code>, <code>drawArrays</code>, <code>drawRangeElements</code> and their
        instanced variants, WebGL 2.0 performs additional error checking beyond that specified in OpenGL ES 3.0:
        <ul>
          <li>If the <code>CURRENT_PROGRAM</code> is null, an <code>INVALID_OPERATION</code> error will be generated;</li>
          <li><a href="#RANGE_CHECKING">Range Checking</a>;</li>
          <li><a href="#ENABLED_ATTRIBUTE">Enabled Attribute</a>;</li>
          <li><a href="#ACTIVE_UNIFORM_BLOCK_BACKING">Active Uniform Block Backing</a>;</li>
          <li><a href="#ATTRIBUTE_TYPE_MATCH">VertexAttrib function must match shader attribute type</a>.</li>
        </ul>
    </p>

<!-- ======================================================================================================= -->

    <h4><a name="readpixels">Reading back pixels</a></h4>

    <p>Pixels in the current framebuffer can be read back into an ArrayBufferView object or a
       WebGLBuffer bound to the <code>PIXEL_PACK_BUFFER</code> target.
    <p>Only differences from <a href="../1.0/index.html#readpixels">Reading back pixels</a> in WebGL 1.0 are described here.</p>
    <dl class="methods">
        <dt class="idl-code">
          void readPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format,
                          GLenum type, [AllowShared] ArrayBufferView dstData, GLuint dstOffset)
          <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-4.3.2">OpenGL ES 3.0 &sect;4.3.2</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glReadPixels.xhtml">man page</a>)</span>
        </dt>
        <dd>
          <p>If a WebGLBuffer is bound to the <code>PIXEL_PACK_BUFFER</code> target, generates an <code>INVALID_OPERATION</code> error.</p>
          <p>
              If <a href="#PIXEL_STORE_PARAM_CONSTRAINTS">pixel store parameter constraints</a> are not met,
              generates an <code>INVALID_OPERATION</code> error.
          </p>
          <p>If <code>dstData</code> doesn't have enough space for the read operation starting at
             <code>dstOffset</code>, generate <code>INVALID_OPERATION</code>.
        </dd>

        <dt class="idl-code">void readPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLintptr offset)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-4.3.2">OpenGL ES 3.0 &sect;4.3.2</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glReadPixels.xhtml">man page</a>)</span>
        </dt>
        <dd>
          <p>If no WebGLBuffer is bound to the <code>PIXEL_PACK_BUFFER</code> target, generates an
             <code>INVALID_OPERATION</code> error.
          <p><em>offset</em> is the byte offset into the WebGLBuffer's data store; generates an
             <code>INVALID_VALUE</code> error if it's less than 0. If the remainder of the
             WebGLBuffer's data store is not large enough to retrieve all of the pixels in the
             specified rectangle taking into account pixel store modes, generates an
             <code>INVALID_OPERATION</code>.
        </dd>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Multiple render targets</h4>

    <dl class="methods">
      <dt>
        <p class="idl-code">void drawBuffers(sequence&lt;GLenum&gt; buffers)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-4.2.1">OpenGL ES 3.0.4 &sect;4.2.1</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glDrawBuffers.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Define the draw buffers to which all fragment colors are written.
      </dd>
      <dt>
        <div class="idl-code">
          <p>void clearBufferfv(GLenum buffer, GLint drawbuffer, Float32List values,
                                optional GLuint srcOffset = 0);</p>
          <p>void clearBufferiv(GLenum buffer, GLint drawbuffer, Int32List values,
                                optional GLuint srcOffset = 0);</p>
          <p>void clearBufferuiv(GLenum buffer, GLint drawbuffer, Uint32List values,
                                 optional GLuint srcOffset = 0);</p>
          <p>void clearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
            <span class="gl-spec">
              (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-4.2.3">OpenGL ES 3.0.4 &sect;4.2.3</a>,
              <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glClearBuffer.xhtml" class="nonnormative">man page</a>)
            </span>
          </p>
        </div>
      </dt>
      <dd>
        Set every pixel in the specified buffer to a constant value. The <code>clearBuffer</code>
        function that should be used for a color buffer depends on the type of the color buffer,
        given in the following table:

        <table>
          <tr><th>Type of buffer</th><th>clearBuffer function</th></tr>
          <tr><td>floating point</td><td>clearBufferfv</td></tr>
          <tr><td>fixed point</td><td>clearBufferfv</td></tr>
          <tr><td>signed integer</td><td>clearBufferiv</td></tr>
          <tr><td>unsigned integer</td><td>clearBufferuiv</td></tr>
        </table><br>
        If <code>buffer</code> is <code>COLOR_BUFFER</code> and the function is not chosen according to the
        above table, an <code>INVALID_OPERATION</code> error is generated and nothing is cleared.

        <p>For ArrayBufferView entrypoints, if there's not enough elements in <code>values</code>
           starting at <code>srcOffset</code>, generate <code>INVALID_VALUE</code>.

        <p><code>clearBufferfi</code> may be used to clear the depth and stencil buffers.
          <code>buffer</code> must be <code>DEPTH_STENCIL</code> and <code>drawBuffer</code> must be
          zero. <code>depth</code> and <code>stencil</code> are the depth and stencil values,
          respectively.</p>

        <p>If this function attempts to clear a missing attachment of a complete framebuffer, nothing
           is cleared and no error is generated
           per <a href="../1.0/index.html#DRAWING_TO_MISSING_ATTACHMENT">Drawing to a Missing Attachment</a>.
      </dd>
    </dl>
<!-- ======================================================================================================= -->

    <h4>Query objects</h4>

    <dl class="methods">
      <dt>
        <p class="idl-code">WebGLQuery? createQuery()
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.13">OpenGL ES 3.0.4 &sect;2.13</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glGenQueries.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Create a WebGLQuery object and initialize it with a query object name as if by calling glGenQueries.
      </dd>
      <dt>
        <p class="idl-code">void deleteQuery(WebGLQuery? query)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.13">OpenGL ES 3.0.4 &sect;2.13</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glDeleteQueries.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Mark for deletion the query object contained in the passed
        <code class="interface">WebGLQuery</code>, as if by calling glDeleteQueries.
        If the object has already been marked for deletion, the call has no effect. Note that
        underlying GL object will be automatically marked for deletion when the JS object is
        destroyed, however this method allows authors to mark an object for deletion early.
      </dd>
      <dt>
        <p class="idl-code">[WebGLHandlesContextLoss] GLboolean isQuery(WebGLQuery? query)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-6.1.7">OpenGL ES 3.0.4 &sect;6.1.7</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glIsQuery.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Return true if the passed <code class="interface">WebGLQuery</code> is valid and false otherwise.<br><br>

        Returns false if the query's <a href="../1.0/index.html#webgl-object-invalidated-flag">invalidated
        flag</a> is set.
      </dd>
      <dt>
        <p class="idl-code">void beginQuery(GLenum target, WebGLQuery query)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.13">OpenGL ES 3.0.4 &sect;2.13</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glBeginQuery.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Begin an asynchronous query. <em>Target</em> indicates the type of query to be performed.
      </dd>
      <dt>
        <p class="idl-code">void endQuery(GLenum target)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.13">OpenGL ES 3.0.4 &sect;2.13</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glBeginQuery.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Mark the end of the sequence of commands to be tracked for the query type given by
        <em>target</em>. When the final query result is available, the query object is updated
        to indicate this and the result may be retrieved by calling <code>getQueryParameter</code>.
      </dd>
      <dt>
        <p class="idl-code">WebGLQuery? getQuery(GLenum target, GLenum pname)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-6.1.7">OpenGL ES 3.0.4 &sect;6.1.7</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glGetQueryiv.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
          <p>Returns information about a query target <em>target</em>, which must be one
          of <code>ANY_SAMPLES_PASSED</code> or <code>ANY_SAMPLES_PASSED_CONSERVATIVE</code> for
          occlusion queries, or <code>TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN</code> for primitive
          queries. <em>pname</em> specifies the symbolic name of a query object target
          parameter. Currently it must be <code>CURRENT_QUERY</code>, and returns either the
          currently active query for the target, or null.</p>

          <p>If <em>target</em> or <em>pname</em> are not in the list above, generates
          an <code>INVALID_ENUM</code> error and returns null.</p>

          <p>Returns null if any OpenGL errors are generated during the execution of this
          function.</p>
      </dd>
      <dt>
        <p class="idl-code"><a name="GET_QUERY_PARAMETER">any getQueryParameter</a>(WebGLQuery query, GLenum pname)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-6.1.7">OpenGL ES 3.0.4 &sect;6.1.7</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glGetQueryObjectuiv.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
          <p>Returns a parameter <em>pname</em> of a query object. <code>QUERY_RESULT</code> returns
          the value of the query object's passed samples counter.
          <code>QUERY_RESULT_AVAILABLE</code> returns whether the samples counter is immediately
          available. The type returned is the natural type for the requested pname, as given in the
          following table:</p>
          <table>
              <tr><th>pname</th><th>returned type</th></tr>
              <tr><td>QUERY_RESULT</td><td>GLuint</td></tr>
              <tr><td>QUERY_RESULT_AVAILABLE</td><td>GLboolean</td></tr>
          </table>

          <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code>
          error and returns null.</p>

          <p>If <em>query</em> is not a valid query object, or is a currently active query object,
          generates an <code>INVALID_OPERATION</code> error and returns null.

          <p>Returns null if any OpenGL errors are generated during the execution of this
          function.</p>

          <p>In order to ensure consistent behavior across platforms, queries' results must only be made
          available when the user agent's <a
          href="http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#event-loops">event
          loop</a> is not executing a task. In other words:
          <ul>
            <li> A query's result must not be made available until control has returned to the user
                 agent's main loop. </li>
            <li> Repeatedly fetching a query's QUERY_RESULT_AVAILABLE parameter in a loop, without
                 returning control to the user agent, must always return the same value. </li>
          </ul>
          </p>

          <div class="note">
            A query's result may or may not be made available when control returns to the user
            agent's event loop. It is not guaranteed that using a single setTimeout callback with a
            delay of 0, or a single requestAnimationFrame callback, will allow sufficient time for
            the WebGL implementation to supply the query's results.
          </div>

          <div class="note rationale">
            This change compared to the OpenGL ES 3.0 specification is enforced in order to prevent
            applications from relying on being able to issue a query and fetch its result in the
            same frame. In order to ensure best portability among devices and best performance among
            implementations, applications must expect that queries' results will become available
            asynchronously.
          </div>
      </dd>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Sampler objects</h4>

    <dl class="methods">
      <dt>
        <p class="idl-code">WebGLSampler? createSampler()
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.2">OpenGL ES 3.0.4 &sect;3.8.2</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glGenSamplers.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Create a <code class="interface">WebGLSampler</code> object and initialize it with a sampler object name as if by
        calling glGenSamplers.
      </dd>
      <dt>
        <p class="idl-code">void deleteSampler(WebGLSampler? sampler)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.2">OpenGL ES 3.0.4 &sect;3.8.2</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glDeleteSamplers.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Mark for deletion the sampler object contained in the passed
        <code class="interface">WebGLSampler</code>, as if by calling glDeleteSamplers.
        If the object has already been marked for deletion, the call has no effect. Note that
        underlying GL object will be automatically marked for deletion when the JS object is
        destroyed, however this method allows authors to mark an object for deletion early.
      </dd>
      <dt>
        <p class="idl-code">[WebGLHandlesContextLoss] GLboolean isSampler(WebGLSampler? sampler)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.2">OpenGL ES 3.0.4 &sect;3.8.2</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glIsSampler.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Return true if the passed <code class="interface">WebGLSampler</code> is valid and false otherwise. <br><br>

        Returns false if the sampler's <a href="../1.0/index.html#webgl-object-invalidated-flag">invalidated
        flag</a> is set.
      </dd>
      <dt>
        <p class="idl-code">void bindSampler(GLuint unit, WebGLSampler? sampler)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.2">OpenGL ES 3.0.4 &sect;3.8.2</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glBindSampler.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Bind the sampler object contained in the passed <code>WebGLSampler</code> to the texture unit at the
        passed index. If a sampler is bound to a texture unit, the sampler's state supersedes the sampling
        state of the texture bound to that texture unit. If <code class="param">sampler</code> is null, the
        currently bound sampler is unbound from the texture unit. A single sampler object may be bound to
        multiple texture units simultaneously. <br><br>
        If <em>unit</em> is greater than or equal to the value of <code>MAX_COMBINED_TEXTURE_IMAGE_UNITS</code>, generates an <code>INVALID_VALUE</code> error.<br><br>
        An attempt to bind an object marked for deletion will generate an
        <code>INVALID_OPERATION</code> error, and the current binding will remain untouched.
      </dd>
      <dt>
        <p class="idl-code">void samplerParameteri(WebGLSampler sampler, GLenum pname, GLint param)</p>
        <p class="idl-code">void samplerParameterf(WebGLSampler sampler, GLenum pname, GLfloat param)</p>
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8.2">OpenGL ES 3.0.4 &sect;3.8.2</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glSamplerParameter.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Set the value for the passed pname given the passed sampler. <em>pname</em> is given in the following table:
        <table>
            <tr><th>pname</th></tr>
            <tr><td>TEXTURE_COMPARE_FUNC</td></tr>
            <tr><td>TEXTURE_COMPARE_MODE</td></tr>
            <tr><td>TEXTURE_MAG_FILTER</td></tr>
            <tr><td>TEXTURE_MAX_LOD</td></tr>
            <tr><td>TEXTURE_MIN_FILTER</td></tr>
            <tr><td>TEXTURE_MIN_LOD</td></tr>
            <tr><td>TEXTURE_WRAP_R</td></tr>
            <tr><td>TEXTURE_WRAP_S</td></tr>
            <tr><td>TEXTURE_WRAP_T</td></tr>
        </table>
        <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>
        <p>If <em>sampler</em> is not a valid sampler object, generates an <code>INVALID_OPERATION</code> error.</p>
      </dd>
      <dt class="idl-code">any getSamplerParameter(WebGLSampler sampler, GLenum pname)
          <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-6.1.5">OpenGL ES 3.0.4 &sect;6.1.5</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glGetSamplerParameter.xhtml">man page</a>)</span>
      </dt>
      <dd>
          Return the information requested in pname about the given WebGLSampler, passed as <em>sampler</em>. The
          type returned is dependent on the information requested, as shown in the following table:
          <table>
              <tr><th>pname</th><th>returned type</th></tr>
              <tr><td>TEXTURE_COMPARE_FUNC</td><td>GLenum</td></tr>
              <tr><td>TEXTURE_COMPARE_MODE</td><td>GLenum</td></tr>
              <tr><td>TEXTURE_MAG_FILTER</td><td>GLenum</td></tr>
              <tr><td>TEXTURE_MAX_LOD</td><td>GLfloat</td></tr>
              <tr><td>TEXTURE_MIN_FILTER</td><td>GLenum</td></tr>
              <tr><td>TEXTURE_MIN_LOD</td><td>GLfloat</td></tr>
              <tr><td>TEXTURE_WRAP_R</td><td>GLenum</td></tr>
              <tr><td>TEXTURE_WRAP_S</td><td>GLenum</td></tr>
              <tr><td>TEXTURE_WRAP_T</td><td>GLenum</td></tr>
          </table>
          <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>
          <p>If <em>sampler</em> is not a valid sampler object, generates an <code>INVALID_OPERATION</code> error.</p>
          <p>Returns null if any OpenGL errors are generated during the execution of this function.</p>
      </dd>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Sync objects</h4>

    <p>
        Sync objects can be used to synchronize execution between the GL server and the client.
    </p>

    <dl class="methods">
      <dt>
        <p class="idl-code">WebGLSync? fenceSync(GLenum condition, GLbitfield flags)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-5.2">OpenGL ES 3.0.4 &sect;5.2</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glFenceSync.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
          Create a new fence sync object and insert an associated fence command in the GL command stream.
      </dd>
      <dt>
        <p class="idl-code">[WebGLHandlesContextLoss] GLboolean isSync(WebGLSync? sync)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-6.1.8">OpenGL ES 3.0.4 &sect;6.1.8</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glIsSync.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
          Return true if the passed <code class="interface">WebGLSync</code> is valid and false otherwise. <br><br>

          Returns false if the sync's <a href="../1.0/index.html#webgl-object-invalidated-flag">invalidated
          flag</a> is set.
      </dd>
      <dt>
        <p class="idl-code">void deleteSync(WebGLSync? sync)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-5.2">OpenGL ES 3.0.4 &sect;5.2</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glDeleteSync.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
          Mark for deletion the sync object contained in the passed
          <code class="interface">WebGLSync</code>, as if by calling glDeleteSync.
          If the object has already been marked for deletion, the call has no effect. Note that
          underlying GL object will be automatically marked for deletion when the JS object is
          destroyed, however this method allows authors to mark an object for deletion early.
      </dd>
      <dt>
        <p class="idl-code"><a name="CLIENT_WAIT_SYNC">GLenum clientWaitSync(WebGLSync sync, GLbitfield flags, GLuint64 timeout)</a>
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-5.2.1">OpenGL ES 3.0.4 &sect;5.2.1</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glClientWaitSync.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        <p>
        Block execution until the passed sync object is signaled or the specified timeout has
        passed. <code>timeout</code> is in units of nanoseconds.
        </p>

        <p>
        Returns one of four status values. A return value of <code>ALREADY_SIGNALED</code> indicates
        that <code>sync</code> was signaled at the time <code>clientWaitSync</code> was
        called. <code>ALREADY_SIGNALED</code> will always be returned if <code>sync</code> was signaled, even
        if <code>timeout</code> was zero. A return value of <code>TIMEOUT_EXPIRED</code> indicates that the specified
        timeout period expired before <code>sync</code> was signaled. A return value of <code>CONDITION_SATISFIED</code>
        indicates that <code>sync</code> was signaled before the timeout expired. Finally, if an error occurs, in
        addition to generating an error as specified below, returns <code>WAIT_FAILED</code> without blocking.
        </p>

        <p>
        <code>flags</code> controls command flushing behavior and may include <code>SYNC_FLUSH_COMMANDS_BIT</code>. If
        any other bit is set in <code>flags</code> an <code>INVALID_OPERATION</code> error is
        generated. If <code>SYNC_FLUSH_COMMANDS_BIT</code> is set in <code>flags</code> and <code>sync</code> is
        unsignaled when <code>clientWaitSync</code> is called, then the equivalent of <code>flush</code> will be
        performed before blocking on <code>sync</code>.
        </p>

        <p>
        As discussed in the <a href="#CLIENT_WAIT_SYNC">differences section</a>, WebGL implementations must impose a
        short maximum timeout to prevent blocking the main thread for long periods of time. The
        implementation-defined timeout may be queried by calling <code>getParameter</code> with the
        argument <code>MAX_CLIENT_WAIT_TIMEOUT_WEBGL</code>. If <code>timeout</code> is larger than this
        implementation-defined timeout then an <code>INVALID_OPERATION</code> error is generated.
        </p>

        <div class="note">
        The implementation-defined maximum timeout is not specified. It should be set low enough to keep applications
        from compromising interactivity by waiting for long periods of time. It is acceptable for an implementation to
        impose a zero maximum timeout. WebGL applications should not use clientWaitSync to block execution for long
        periods of time.
        </div>

        <p>Returns <code>WAIT_FAILED</code> if any OpenGL errors are generated during the execution of this
        function.</p>

        <p>In order to ensure consistent behavior across platforms, sync objects may only transition
        to the signaled state when the user
        agent's <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#event-loops">event
        loop</a> is not executing a task. In other words:
        <ul>
          <li> clientWaitSync must not return CONDITION_SATISFIED or ALREADY_SIGNALED for a newly
               created sync object until control has returned to the user agent's main loop. </li>
        </ul>
        </p>
      </dd>
      <dt>
        <p class="idl-code">void waitSync(WebGLSync sync, GLbitfield flags, GLint64 timeout)
          <span class="gl-spec">
            (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-5.2.1">OpenGL ES 3.0.4 &sect;5.2.1</a>,
            <a href="http://www.khronos.org/opengles/sdk/docs/man3/html/glWaitSync.xhtml" class="nonnormative">man page</a>)
          </span>
        </p>
      </dt>
      <dd>
        Return immediately, but wait on the GL server until the passed sync object is signaled or an
        implementation-dependent timeout has passed. The passed <em>timeout</em> must be set to
        <code>TIMEOUT_IGNORED</code>.

        <div class="note">
          In the absence of the possibility of synchronizing between multiple GL contexts, calling waitSync is effectively a no-op.
        </div>
      </dd>
      <dt class="idl-code"><a name="GET_SYNC_PARAMETER">any getSyncParameter(WebGLSync sync, GLenum pname)</a>
          <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-6.1.8">OpenGL ES 3.0.4 &sect;6.1.8</a>, <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glGetSynciv.xhtml">man page</a>)</span>
      </dt>
      <dd>
          Return the value for the passed pname given the passed WebGLSync object. The type returned is the natural
          type for the requested pname, as given in the following table:
          <table>
              <tr><th>pname</th><th>returned type</th></tr>
              <tr><td>OBJECT_TYPE</td><td>GLenum</td></tr>
              <tr><td>SYNC_STATUS</td><td>GLenum</td></tr>
              <tr><td>SYNC_CONDITION</td><td>GLenum</td></tr>
              <tr><td>SYNC_FLAGS</td><td>GLbitfield</td></tr>
          </table>
          <p>If <em>pname</em> is not in the table above, generates an <code>INVALID_ENUM</code> error and returns null.</p>
          <p>Returns null if any OpenGL errors are generated during the execution of this
          function.</p>

          <p>In order to ensure consistent behavior across platforms, sync objects may only
          transition to the signaled state when the user agent's <a
          href="http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#event-loops">event
          loop</a> is not executing a task. In other words:
          <ul>
            <li> A sync object must not become signaled until control has returned to the user
                 agent's main loop. </li>
            <li> Repeatedly fetching a sync object's SYNC_STATUS parameter in a loop, without
                 returning control to the user agent, must always return the same value. </li>
          </ul>
          </p>
      </dd>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Transform feedback</h4>

    <p>
        Transform feedback mode captures the values of output variables written by the vertex shader. The
        vertices are captured before flatshading and clipping. The transformed vertices may be optionally
        discarded after being stored into one or more buffer objects, or they can be passed on down to the
        clipping stage for further processing. The set of output variables captured is determined when a
        program is linked.
    </p>

    <p>
        If any output variable is specified to be streamed to a transform feedback buffer object but not actually
        written by a vertex shader, the value is set to 0. See <a href="#TRANSFORM_FEEDBACK_NOT_WRITTEN">
        Transform feedback primitive capture</a>.
    </p>

    <dl class="methods">
        <dt class="idl-code">WebGLTransformFeedback? createTransformFeedback()
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.14.1">OpenGL ES 3.0.4 &sect;2.14.1</a>,
            similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glGenTransformFeedbacks.xhtml">glGenTransformFeedbacks</a>)</span>
        <dd>
            Create a <code class="interface">WebGLTransformFeedback</code> object and initialize it with a transform feedback object name as if by
            calling glGenTransformFeedbacks.

        <dt class="idl-code">void deleteTransformFeedback(WebGLTransformFeedback? transformFeedback)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.14.1">OpenGL ES 3.0.4 &sect;2.14.1</a>,
            similar to <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glDeleteTransformFeedbacks.xhtml">glDeleteTransformFeedbacks</a>)</span>
        <dd>
            Mark for deletion the transform feedback object contained in the passed
            <code class="interface">WebGLTransformFeedback</code>, as if by calling
            glDeleteTransformFeedbacks.
            If the object has already been marked for deletion, the call has no effect. Note that
            underlying GL object will be automatically marked for deletion when the JS object is
            destroyed, however this method allows authors to mark an object for deletion early.

        <dt class="idl-code">[WebGLHandlesContextLoss] GLboolean isTransformFeedback(WebGLTransformFeedback? transformFeedback)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-6.1.11">OpenGL ES 3.0.4 &sect;6.1.11</a>,
            <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glIsTransformFeedback.xhtml">man page</a>)</span>
        <dd>
            Return true if the passed <code class="interface">WebGLTransformFeedback</code> is valid and false otherwise. <br><br>

            Returns false if the transform feedback's <a href="../1.0/index.html#webgl-object-invalidated-flag">invalidated
            flag</a> is set.

        <dt class="idl-code">void bindTransformFeedback (GLenum target, WebGLTransformFeedback? transformFeedback)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.14.1">OpenGL ES 3.0.4 &sect;2.14.1</a>,
            <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glBindTransformFeedback.xhtml">man page</a>)</span>
        <dd>
            Bind the given <code class="interface">WebGLTransformFeedback</code> object.
            If <code class="param">transformFeedback</code> is null, the default transform feedback object provided by the context
            is bound.
            An attempt to bind an object marked for deletion will generate an
            <code>INVALID_OPERATION</code> error, and the current binding will remain untouched.

        <dt class="idl-code">void beginTransformFeedback(GLenum primitiveMode)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.14.2">OpenGL ES 3.0.4 &sect;2.14.2</a>,
            <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glBeginTransformFeedback.xhtml">man page</a>)</span>
        <dd>

        <dt class="idl-code">void endTransformFeedback()
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.14.2">OpenGL ES 3.0.4 &sect;2.14.2</a>,
            <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glBeginTransformFeedback.xhtml">man page</a>)</span>
        <dd>

        <dt class="idl-code">void pauseTransformFeedback()
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.14.2">OpenGL ES 3.0.4 &sect;2.14.2</a>,
            <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glPauseTransformFeedback.xhtml">man page</a>)</span>
        <dd>

        <dt class="idl-code">void resumeTransformFeedback()
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.14.2">OpenGL ES 3.0.4 &sect;2.14.2</a>,
            <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glResumeTransformFeedback.xhtml">man page</a>)</span>
        <dd>

        <dt class="idl-code">void transformFeedbackVaryings(WebGLProgram program, sequence&lt;DOMString&gt; varyings, GLenum bufferMode)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.11.8">OpenGL ES 3.0.4 &sect;2.11.8</a>,
            <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glTransformFeedbackVaryings.xhtml">man page</a>)</span>
        <dd>

        <dt class="idl-code">WebGLActiveInfo? getTransformFeedbackVarying(WebGLProgram program, GLuint index)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.11.8">OpenGL ES 3.0.4 &sect;2.11.8</a>,
            <a class="nonnormative" href="http://www.khronos.org/opengles/sdk/docs/man3/html/glGetTransformFeedbackVarying.xhtml">man page</a>)</span>
        <dd>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Uniform Buffer objects</h4>

    <p>
        Uniform buffer objects provide the storage for named uniform blocks, so the values of active uniforms
        in named uniform blocks may be changed by modifying the contents of the buffer object.
    </p>

    <dl class="methods">
        <dt class="idl-code">void bindBufferBase(GLenum target, GLuint index, WebGLBuffer? buffer)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.9.1">OpenGL ES 3.0.4 &sect;2.9.1</a>,
            <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glBindBufferBase.xhtml">man page</a>)</span>
        <dd>
            Binds the given <code class="interface">WebGLBuffer</code> object to the binding point at <code class="param">index</code> of the array of targets
            specified by <code class="param">target</code>.

        <dt class="idl-code">void bindBufferRange(GLenum target, GLuint index, WebGLBuffer? buffer, GLintptr offset, GLsizeiptr size)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.9.1">OpenGL ES 3.0.4 &sect;2.9.1</a>,
            <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glBindBufferRange.xhtml">man page</a>)</span>
        <dd>
            Binds a range of the <code class="interface">WebGLBuffer</code> object buffer represented by <code class="param">offset</code> and <code class="param">size</code>
            to the binding point at <code class="param">index</code> of the array of targets specified by <code class="param">target</code>.

        <dt class="idl-code">sequence&lt;GLuint&gt;? getUniformIndices(WebGLProgram program, sequence&lt;DOMString&gt; uniformNames)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.11.6">OpenGL ES 3.0.4 &sect;2.11.6</a>,
            <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glGetUniformIndices.xhtml">man page</a>)</span>
        <dd>
            Retrieves the indices of a number of uniforms within <code class="param">program</code>.

        <dt class="idl-code">any getActiveUniforms(WebGLProgram program, sequence&lt;GLuint&gt; uniformIndices, GLenum pname)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.11.6">OpenGL ES 3.0.4 &sect;2.11.6</a>,
            <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glGetActiveUniformsiv.xhtml">man page</a>)</span>
        <dd>
            Queries the value of the parameter named <code class="param">pname</code> for each of the uniforms within <code class="param">program</code> whose indices
            are specified in the array of <code class="param">uniformIndices</code>. The type returned is the natural type for the requested
            <code class="param">pname</code>, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>UNIFORM_TYPE</td><td>sequence&lt;GLenum&gt;</td></tr>
                <tr><td>UNIFORM_SIZE</td><td>sequence&lt;GLuint&gt;</td></tr>
                <tr><td>UNIFORM_BLOCK_INDEX</td><td>sequence&lt;GLint&gt;</td></tr>
                <tr><td>UNIFORM_OFFSET</td><td>sequence&lt;GLint&gt;</td></tr>
                <tr><td>UNIFORM_ARRAY_STRIDE</td><td>sequence&lt;GLint&gt;</td></tr>
                <tr><td>UNIFORM_MATRIX_STRIDE</td><td>sequence&lt;GLint&gt;</td></tr>
                <tr><td>UNIFORM_IS_ROW_MAJOR</td><td>sequence&lt;GLboolean&gt;</td></tr>
            </table><br>
            <p>If <code class="param">pname</code> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>

        <dt class="idl-code">GLuint getUniformBlockIndex(WebGLProgram program, DOMString uniformBlockName)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.11.6">OpenGL ES 3.0.4 &sect;2.11.6</a>,
            <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glGetUniformBlockIndex.xhtml">man page</a>)</span>
        <dd>
            Retrieves the index of a uniform block within <code class="param">program</code>.

        <dt class="idl-code">any getActiveUniformBlockParameter(WebGLProgram program, GLuint uniformBlockIndex, GLenum pname)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.11.6">OpenGL ES 3.0.4 &sect;2.11.6</a>,
            <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glGetActiveUniformBlockiv.xhtml">man page</a>)</span>
        <dd>
            Retrieves information about an active uniform block within <code class="param">program</code>. The type returned is the natural type for the requested
            <code class="param">pname</code>, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>UNIFORM_BLOCK_BINDING</td><td>GLuint</td></tr>
                <tr><td>UNIFORM_BLOCK_DATA_SIZE</td><td>GLuint</td></tr>
                <tr><td>UNIFORM_BLOCK_ACTIVE_UNIFORMS</td><td>GLuint</td></tr>
                <tr><td>UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES</td><td>Uint32Array</td></tr>
                <tr><td>UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER</td><td>GLboolean</td></tr>
                <tr><td>UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER</td><td>GLboolean</td></tr>
            </table><br>
            <p>If <code class="param">pname</code> is not in the table above, generates an <code>INVALID_ENUM</code> error.</p>
            <p>If <code class="param">uniformBlockIndex</code> is not an active block uniform for <code class="param">program</code> or greater than or equal to the
            value of <code>ACTIVE_UNIFORM_BLOCKS</code>, generates an <code>INVALID_VALUE</code> error.</p>
            <p>If an OpenGL error is generated, returns null.</p>

        <dt class="idl-code">DOMString? getActiveUniformBlockName(WebGLProgram program, GLuint uniformBlockIndex)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.11.6">OpenGL ES 3.0.4 &sect;2.11.6</a>,
            <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glGetActiveUniformBlockName.xhtml">man page</a>)</span>
        <dd>
            Retrieves the name of the active uniform block at <code class="param">uniformBlockIndex</code> within <code class="param">program</code>.

        <dt class="idl-code">void uniformBlockBinding(WebGLProgram program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.11.6">OpenGL ES 3.0.4 &sect;2.11.6</a>,
            <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glUniformBlockBinding.xhtml">man page</a>)</span>
        <dd>
            Assigns binding points for active uniform blocks.
    </dl>

<!-- ======================================================================================================= -->

    <h4>Vertex Array objects</h4>

    <p>
        Vertex Array objects (sometimes referred to as VAOs) encapsulate all state related to the
        definition of data used by the vertex processor.
    </p>

    <dl class="methods">
        <dt class="idl-code">void bindVertexArray(WebGLVertexArrayObject? vertexArray)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.10">OpenGL ES 3.0.4 &sect;2.10</a>,
            <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glBindVertexArray.xhtml">man page</a>)</span>
        <dd>
            Bind the given <code class="interface">WebGLVertexArrayObject</code> object.
            If <code class="param">vertexArray</code> is null, the default vertex array provided by the context
            is bound.
            An attempt to bind a deleted vertex array will generate a <code>INVALID_OPERATION</code> error, and
            the current binding will remain untouched.

        <dt class="idl-code">WebGLVertexArrayObject? createVertexArray()
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.10">OpenGL ES 3.0.4 &sect;2.10</a>,
            similar to <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glGenVertexArrays.xhtml">glGenVertexArrays</a>)</span>
        <dd>
            Create a <code class="interface">WebGLVertexArrayObject</code> object and initialize it with a vertex array object name as if by
            calling glGenVertexArrays.

        <dt class="idl-code">void deleteVertexArray(WebGLVertexArrayObject? vertexArray)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.10">OpenGL ES 3.0.4 &sect;2.10</a>,
            similar to <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glDeleteVertexArrays.xhtml">glDeleteVertexArrays</a>)</span>
        <dd>
            Mark for deletion the vertex array object contained in the passed
            <code class="interface">WebGLVertexArrayObject</code>, as if by calling
            glDeleteVertexArrays.
            If the object has already been marked for deletion, the call has no effect. Note that
            underlying GL object will be automatically marked for deletion when the JS object is
            destroyed, however this method allows authors to mark an object for deletion early.

        <dt class="idl-code">[WebGLHandlesContextLoss] GLboolean isVertexArray(WebGLVertexArrayObject? vertexArray)
            <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-6.1.10">OpenGL ES 3.0.4 &sect;6.1.10</a>,
            <a class="nonnormative" href="https://www.khronos.org/opengles/sdk/docs/man3/html/glIsVertexArray.xhtml">man page</a>)</span>
        <dd>
            Return true if the passed <code class="interface">WebGLVertexArrayObject</code> is valid and false otherwise. <br><br>

            Returns false if the vertex array's <a href="../1.0/index.html#webgl-object-invalidated-flag">invalidated
            flag</a> is set.
    </dl>

<!-- ======================================================================================================= -->

    <h2><a name="webgl_1_2_differences">Other differences Between WebGL 2.0 and WebGL 1.0</a></h2>

    <div class="note editor">
        Needs update for WebGL 2.0
    </div>

    <h3><a name="BACKWARDS_INCOMPATIBILITY">Backwards Incompatibility</a></h3>

    <h4>Errors</h4>

    <p>
        The WebGL 2.0 API may behave differently in cases where the WebGL 1.0 API generates an error.
        Code written against the WebGL 1.0 API that generates errors is not guaranteed to be
        forward-compatible with WebGL 2.0.
    </p>

    <h4>Extensions</h4>

    <p>
        Some extensions that may have been supported in the WebGL 1.0 API are removed from the WebGL
        2.0 API. For more details, see the
        <a href="http://www.khronos.org/registry/webgl/extensions/">WebGL Extension Registry</a>.
    </p>

    <div class="note">
        Extensions are typically removed only if equivalent functionality is available in the WebGL
        2.0 API either in the core specification or in an improved extension. When an application
        using WebGL 1.0 extensions is modified to run on the WebGL 2.0 API, it is often possible to
        create a dummy extension object for each of the promoted extensions which simply
        redirects calls to the appropriate WebGL 2.0 API functions. If the application is using shader
        language extensions, porting shaders to GLSL ES 3.00 is typically required.
    </div>

    <h4>Non-Power-of-Two Texture Access</h4>

    <p>
        Texture access works in the WebGL 2.0 API as in the OpenGL ES 3.0 API. In other words,
        unlike the WebGL 1.0 API, there are no special restrictions on non power of 2 textures. All
        mipmapping and all wrapping modes are supported for non-power-of-two images.
    </p>

    <h4>Primitive Restart is Always Enabled</h4>

    <p>
        See section <a href="#NO_PRIMITIVE_RESTART_FIXED_INDEX">PRIMITIVE_RESTART_FIXED_INDEX is always enabled</a>.
    </p>

    <h4><a name="FBO_ATTACHMENTS">Framebuffer Object Attachments</a></h4>

    <p>In WebGL 1.0, <code>DEPTH_STENCIL_ATTACHMENT</code> is an alternative attachment point other than <code>DEPTH_ATTACHMENT</code> and <code>STENCIL_ATTACHMENT</code>. In WebGL 2.0, however, <code>DEPTH_STENCIL_ATTACHMENT</code> is considered an alias for <code>DEPTH_ATTACHMENT</code> + <code>STENCIL_ATTACHMENT</code>, i.e., the same image is attached to both <code>DEPTH_ATTACHMENT</code> and <code>STENCIL_ATTACHMENT</code>, overwriting the original images attached to the two attachment points.<p>
    <p>Consider the following sequence of actions:
      <ol>
       <li>attach renderbuffer 1 to <code>DEPTH_ATTACHMENT</code>;</li>
       <li>attach renderbuffer 2 to <code>DEPTH_STENCIL_ATTACHMENT</code>;</li>
       <li>attach <em>null</em> to <code>DEPTH_STENCIL_ATTACHMENT</code>.</li>
      </ol>
      In WebGL 1.0, the framebuffer ends up with renderbuffer 1 attached to <code>DEPTH_ATTACHMENT</code> and no image attached to <code>STENCIL_ATTACHMENT</code>; in WebGL 2.0, however, neither <code>DEPTH_ATTACHMENT</code> nor <code>STENCIL_ATTACHMENT</code> has an image attached.</p>
    <p>The constraints defined in <a href="../1.0/index.html#FBO_ATTACHMENTS">Framebuffer Object Attachments</a> no longer apply in WebGL 2.0.</p>
    <p>If different images are bound to the depth and stencil attachment points, <code>checkFramebufferStatus</code> returns <code>FRAMEBUFFER_UNSUPPORTED</code>, and <code>getFramebufferAttachmentParameter</code> with <em>attachment</em> of <code>DEPTH_STENCIL_ATTACHMENT</code> generates an <code>INVALID_OPERATION</code> error.</p>

    <h4>Texture Type in TexSubImage2D Calls</h4>

    <p>
        In the WebGL 1.0 API, the <em>type</em> argument passed to <code>texSubImage2D</code> must
        match the type used to originally define the texture object (i.e., using <code>texImage2D</code>).
        In the WebGL 2.0 API, this restriction has been lifted.
    </p>

    <h4>Out-of-bounds Behaviors in copyTexSubImage2D and readPixels calls</h4>

    <p>
        In WebGL 1.0, <a href="../1.0/index.html#READS_OUTSIDE_FRAMEBUFFER">
        Reading Pixels Outside the Framebuffer</a>, it is required that
        <code>copyTexSubImage2D</code> and <code>readPixels</code> do not touch
        the corresponding destination range for out-of-bound pixels.
    </p>

    <p>
        In WebGL 2.0, when a <code>PACK_BUFFER</code> object is bound and
        <code>PACK_ROW_LENGTH</code> is not zero and less than <em>width</em>,
        or when a <code>UNPACK_BUFFER</code> object is bound and
        <code>UNPACK_ROW_LENGTH</code> is not zero and less than <em>width</em>
        or <code>UNPACK_IMAGE_HEIGHT</code> is not zero and less than <em>height</em>,
        packing/unpacking a row/image may extend to the next row/image. If that
        portion is out-of-bounds, the values may change accordingly.
    </p>

    <h4>Color conversion in copyTex{Sub}Image2D</h4>

    <p>
        In WebGL 1.0 (OpenGL ES 2.0), it is allowed for the component sizes of
        <em>internalformat</em> to be less than the corresponding component sizes
        of the source buffer's internal format. However, in WebGL 2.0 (OpenGL ES 3.0),
        if <em>internalformat</em> is sized, its component sizes must exactly
        match the corresponding component sizes of the source buffer's effective
        internal format.
    </p>

    <p>
        In both WebGL 1.0 and 2.0, source buffer components can be dropped during the
        conversion to <em>internalformat</em>, but new components cannot be added.
    </p>

    <h4>getFramebufferAttachmentParameter with FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</h4>

    <p>
        If <code>getFramebufferAttachmentParameter</code> is called with <em>pname</em>
        <code>FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</code> and <em>attachment</em> has no
        image attached, in WebGL 1.0 / ES 2.0, it generates an <code>INVALID_OPERATION</code>;
        in WebGL 2.0 / ES 3.0, it generates no error and <code>null</code> is returned.
    </p>

    <h3>New Features Supported in the WebGL 2.0 API</h3>

    <ul>
      <li>Pixel buffer objects <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.7.1">OpenGL ES 3.0.4 &sect;3.7.1</a> and <a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-4.3">OpenGL ES 3.0.4 &sect;4.3</a>)</span></li>
      <li>Primitive restart <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.8.1">OpenGL ES 3.0.4 &sect;2.8.1</a>)</span></li>
      <li>Rasterizer discard <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.1">OpenGL ES 3.0.4 &sect;3.1</a>)</span></li>
    </ul>

    <h3>GLSL ES 3.00 support</h3>

    <p>
        In addition to supporting The OpenGL ES Shading Language, Version 1.00, the WebGL 2.0 API also accepts
        shaders written in The OpenGL ES Shading Language, Version 3.00
        <a href="#refsGLES30GLSL">[GLES30GLSL]</a>, with some restrictions.
    </p>

    <ul>
        <li>
            A shader referencing state variables or functions that are available in other versions of GLSL,
            such as that found in versions of OpenGL for the desktop, must not be allowed to load.
        </li>
    </ul>

    <p>
        As in the WebGL 1.0 API, identifiers starting with "webgl_" and "_webgl_" are reserved for use by
        WebGL. A shader which declares a function, variable, structure name, or structure field starting with
        these prefixes must not be allowed to load.
    </p>

    <h4>Maximum GLSL Token Size</h4>

    <p>
        WebGL 1.0 supports tokens up to 256 characters in length. WebGL 2.0 follows The OpenGL ES Shading Language, Version 3.00
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.8">OpenGL ES 3.0.4 &sect;3.8</a>)</span>
        and allows tokens up to 1024 characters in length for both ESSL 1 and ESSL 3 shaders. Shaders containing tokens longer than 1024 characters must fail to compile.
    </p>

    <h4>Maximum Uniform and Attribute Location Lengths</h4>

    <p>
        WebGL 2.0 imposes a limit of 1024 characters on the lengths of uniform and attribute locations.
    </p>

    <h3>Vertex Attribute Divisor</h3>

    <p>
        In the WebGL 2.0 API, vertex attributes which have a non-zero divisor do not advance during calls to
        <code>drawArrays</code> and <code>drawElements</code>.
        <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.9.3">OpenGL ES 3.0.4 &sect;2.9.3</a>)</span>
    </p>

<!-- ======================================================================================================= -->

    <h2><a name="webgl_gl_differences">Differences Between WebGL and OpenGL ES 3.0</a></h2>

    <p>
        This section describes changes made to the WebGL API relative to the
        OpenGL ES 3.0 API to improve portability across various operating
        systems and devices.
    </p>

    <h3><a name="BUFFER_OBJECT_BINDING">Buffer Object Binding</a></h3>

    <table>
        <tr>
            <th>WebGL buffer type</th>
            <th>Binding points that set this type</th>
        </tr>
        <tr>
            <td><em>undefined</em></td>
            <td>none</td>
        </tr>
        <tr>
            <td><em>element array</em></td>
            <td>ELEMENT_ARRAY_BUFFER</td>
        </tr>
        <tr>
            <td><em>other data</em></td>
            <td>all binding points except ELEMENT_ARRAY_BUFFER, COPY_READ_BUFFER and COPY_WRITE_BUFFER</td>
        </tr>
    </table><br>

    <p>
        In the WebGL 2.0 API, buffers have their WebGL buffer type initially set to <em>undefined</em>. Calling
        <code>bindBuffer</code>, <code>bindBufferRange</code> or <code>bindBufferBase</code> with the
        <code>target</code> argument set to any buffer binding point except <code>COPY_READ_BUFFER</code> or
        <code>COPY_WRITE_BUFFER</code> will then set the WebGL buffer type of the buffer being bound
        according to the table above. Binding a buffer with type <em>undefined</em> to
        the <code>COPY_READ_BUFFER</code> or <code>COPY_WRITE_BUFFER</code> binding points will set
        its type to <em>other data</em>.
    </p>

    <p>
        Any call to one of these functions which attempts to bind a deleted buffer will generate a
        <code>INVALID_OPERATION</code> error, and the binding will remain untouched.
    </p>

    <p>
        Any call to one of these functions which attempts to bind a WebGLBuffer that has the <em>element
        array</em> WebGL buffer type to a binding point that falls under <em>other data</em>, or bind a
        WebGLBuffer which has the <em>other data</em> WebGL buffer type to <code>ELEMENT_ARRAY_BUFFER</code>
        will generate an <code>INVALID_OPERATION</code> error, and the state of the binding point will remain
        untouched.
    </p>

    <p>
        This restriction implies that a given buffer object may contain either indices or other data, but
        not both.
    </p>

    <p>
        These restrictions are similar to <a href="../1.0/index.html#BUFFER_OBJECT_BINDING">buffer object binding
        restrictions in the WebGL 1.0 specification</a>.
    </p>

    <div class="note rationale">
        This restriction has been added to prevent writing to index buffers on the GPU, which would make
        doing any CPU-side checks on index data prohibitively expensive. Handling index buffers as different
        from other buffer data also maps better to the Direct3D API.
    </div>

    <h3><a name="COPYING_BUFFERS">Copying Buffers</a></h3>

    <p>
        Attempting to use <code>copyBufferSubData</code> to copy between buffers that have
        <em>element array</em> and <em>other data</em> WebGL buffer types as specified in section
        <a href="#BUFFER_OBJECT_BINDING">Buffer Object Binding</a> generates an
        <code>INVALID_OPERATION</code> error and no copying is performed.
    </p>
    <div class="note rationale">
        Same as with <a href="#BUFFER_OBJECT_BINDING">Buffer Object Binding</a> restrictions above.
    </div>

    <h3>Preventing undefined behavior with Transform Feedback</h3>

    <p>
        A buffer which is simultaneously bound to a TRANSFORM_FEEDBACK_BUFFER binding point in the currently
        bound transform feedback object and any other binding point in the WebGL API cannot be used. Any
        attempted use of such a double bound buffer fails with an <code>INVALID_OPERATION</code> error,
        regardless of whether transform feedback is enabled. For example, readPixels to a PIXEL_PACK_BUFFER
        will fail if the buffer is also bound to the current transform feedback object.
    </p>

    <div class="note rationale">
        If an error were not generated, the values read or written would be undefined. <span class="gl-spec">
        (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.pdf#nameddest=section-2.15.2">
        OpenGL ES 3.0.5 &sect;2.15.2</a>)</span>
    </div>

    <h3>Draw Buffers</h3>

    <p>
        The value of the MAX_COLOR_ATTACHMENTS parameter must be equal to that of the MAX_DRAW_BUFFERS
        parameter.
    </p>
    <div class="note rationale">
        There is no use case for these parameters being different.
    </div>

    <p>
        If an ESSL1 fragment shader writes to neither <code>gl_FragColor</code> nor <code>gl_FragData</code>,
        the values of the fragment colors following shader execution are untouched. If corresponding output
        variables are not defined in an ESSL3 fragment shader, the values of the fragment colors following
        shader execution are untouched.
    </p>
    <p>
        All user-defined output variables default to zero if they are not written during a shader execution.
    </p>

    <div class="note">
        For optimal performance, an output array should not include any elements that are not accessed.
    </div>

    <p>
        If the values written by the fragment shader do not match the format(s) of the corresponding
        color buffer(s) (for example, the output variable is an integer, but the corresponding color
        buffer has a floating-point format, or vice versa), and the color buffer states are not set to
        <code>NONE</code> by <code>DrawBuffers</code>, generates an <code>INVALID_OPERATION</code> error;
        if the color buffer states are set to <code>NONE</code> by <code>DrawBuffers</code>, they remain untouched.
    </p>

    <h3>No Program Binaries</h3>

    <p>
        Accessing binary representations of compiled shader programs is not supported in the WebGL 2.0 API.
        This includes OpenGL ES 3.0 <code>GetProgramBinary</code>, <code>ProgramBinary</code>, and
        <code>ProgramParameteri</code> entry points. In addition, querying the program binary length with
        <code>getProgramParameter</code>, and querying program binary formats with <code>getParameter</code>
        are not supported in the WebGL 2.0 API.
    </p>

    <h3><a name="RANGE_CHECKING">Range Checking</a></h3>

    <p>
        In addition to the range checking specified in the WebGL 1.0 specification section
        <a href="../1.0/index.html#ATTRIBS_AND_RANGE_CHECKING">Enabled Vertex Attributes and Range Checking</a>,
        indices referenced by <code>drawElements</code>, <code>drawRangeElements</code> or
        <code>drawElementsInstanced</code> that are greater than the <code>MAX_ELEMENT_INDEX</code> parameter
        cause the draw call to generate an <code>INVALID_OPERATION</code> error even if they lie within the
        storage of the bound buffer. Range checking is not performed for indices that trigger primitive
        restart if primitive restart is enabled. The range checking specified for <code>drawArrays</code> in
        the WebGL 1.0 API is also applied to <code>drawArraysInstanced</code> in the WebGL 2.0 API.
    </p>
    <div class="note rationale">
        The OpenGL robustness extensions do not specify what happens if indices above MAX_ELEMENT_INDEX are
        used, so passing them to the driver is risky. On platforms where MAX_ELEMENT_INDEX is the same as
        the maximum unsigned integer value this section will have no effect.
    </div>

    <h3><a name="ENABLED_ATTRIBUTE">Enabled Attribute</a></h3>

    <p>
        In the WebGL 2.0 API, attempting to draw with <code>drawArrays</code>, <code>drawElements</code>,
        <code>drawRangeElements</code> or their instanced variants generates an <code>INVALID_OPERATION</code>
        error if there is not at least one enabled vertex attribute array that has a divisor of zero and is
        bound to an active generic attribute value in the program used for the draw command.
    </p>
    <div class="note rationale">
        The removed functionality is an exotic corner case, and Direct3D based implementations of WebGL would
        need to add complex workarounds to support it.
    </div>

    <h3><a name="ACTIVE_UNIFORM_BLOCK_BACKING">Active Uniform Block Backing</a></h3>

    <p>
        In the WebGL 2.0 API, attempting to draw with <code>drawArrays</code>, <code>drawElements</code>,
        <code>drawRangeElements</code> or their instanced variants generates an <code>INVALID_OPERATION</code>
        error if any active uniform block in the program used for the draw command is not backed by a
        sufficiently large buffer object.
    </p>
    <div class="note rationale">
        In OpenGL, insufficient uniform block backing is allowed to cause GL interruption or termination.
        See OpenGL ES 3.0 specification section 2.12.6 <span class="gl-spec">
        (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.12.6">
        OpenGL ES 3.0.4 &sect;2.12.6</a>), under "Uniform Buffer Object Bindings."
    </div>

    </div>

    <h3>Default Framebuffer</h3>

    <p>
        WebGL always has a default framebuffer. The <code>FRAMEBUFFER_UNDEFINED</code> enumerant is removed
        from the WebGL 2.0 API.
    </p>

    <h3><a name="STRING_LENGTH_QUERIES">String Length Queries</a></h3>

    <p>
        In the WebGL 2.0 API, the enumerants <code>ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH</code>,
        <code>TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH</code>, <code>UNIFORM_BLOCK_NAME_LENGTH</code>, and
        <code>UNIFORM_NAME_LENGTH</code> are removed in addition to similar
        <a href="../1.0/index.html#STRING_LENGTH_QUERIES">enumerants removed in the WebGL 1.0 API</a>.
    </p>

    <h3>Invalid Clears</h3>

    <p>
        In the WebGL 2.0 API, trying to perform a clear when there is a mismatch between the type of the
        specified clear value and the type of a buffer that is being cleared generates an
        <code>INVALID_OPERATION</code> error instead of producing undefined results.
    </p>

    <h3>Invalid Texture Offsets</h3>

    <p>
        A GLSL shader which attempts to use a texture offset value outside the range specified by
        implementation-defined parameters <code>MIN_PROGRAM_TEXEL_OFFSET</code> and
        <code>MAX_PROGRAM_TEXEL_OFFSET</code> in texture lookup function arguments must fail
        compilation in the WebGL 2.0 API.
    </p>

    <div class="note rationale">
        Using an offset outside the valid range returns undefined results, so it can not be allowed.
        The offset must be a constant expression according to the GLSL ES spec, so checking the
        value against the correct range can be done at compile time.
    </div>

    <h3>Texel Fetches</h3>

    <p>
        Texel fetches that have undefined results in the OpenGL ES 3.0 API must return zero, or a texture
        source color of (0, 0, 0, 1) in the case of a texel fetch from an incomplete texture in the WebGL 2.0
        API.
    </p>
    <div class="note rationale">
        Behavior of out-of-range texel fetches needs to be testable in order to guarantee security.
    </div>

    <h3>GLSL ES 1.00 Fragment Shader Output</h3>

    <p>
        A fragment shader written in The OpenGL ES Shading Language, Version 1.00, that statically assigns a
        value to <code>gl_FragData[n]</code> where <code>n</code> does not equal constant value 0 must fail
        to compile in the WebGL 2.0 API. This is to achieve consistency with The OpenGL ES 3.0 specification
        section 4.2.1 <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-4.2.1">OpenGL ES 3.0.4 &sect;4.2.1</a>)</span>
        and The OpenGL ES Shading Language 3.00.6 specification section 1.5 <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/GLSL_ES_Specification_3.00.pdf#nameddest=section-1.5">GLSL ES 3.00.6 &sect;1.5</a>)</span>.
        As in the OpenGL ES 3.0 API, multiple fragment shader outputs are only supported for GLSL ES 3.00
        shaders in the WebGL 2.0 API.
    </p>

    <h3>No MapBufferRange</h3>

    <p>
        The <code>MapBufferRange</code>, <code>FlushMappedBufferRange</code>, and <code>UnmapBuffer</code>
        entry points are removed from the WebGL 2.0 API. The following enum values are also removed:
        <code>BUFFER_ACCESS_FLAGS</code>, <code>BUFFER_MAP_LENGTH</code>, <code>BUFFER_MAP_OFFSET</code>,
        <code>MAP_READ_BIT</code>, <code>MAP_WRITE_BIT</code>, <code>MAP_INVALIDATE_RANGE_BIT</code>,
        <code>MAP_INVALIDATE_BUFFER_BIT</code>, <code>MAP_FLUSH_EXPLICIT_BIT</code>, and
        <code>MAP_UNSYNCHRONIZED_BIT</code>.
    </p>

    <div class="note">
        Instead of using <code>MapBufferRange</code>, buffer data may be read by using the
        <code>getBufferSubData</code> entry point.
    </div>

    <h3><a name="TIMEOUT_IGNORED">TIMEOUT_IGNORED</a></h3>
    <p>
        In the WebGL 2.0 API <code>TIMEOUT_IGNORED</code> is defined as a <code>GLint64</code> with the value
        <code>-1</code> instead of a <code>GLuint64</code> with the value <code>0xFFFFFFFFFFFFFFFF</code>. This
        is because Javascript cannot accurately represent an integer that large. For the same reason
        <code>waitSync</code> takes <code>GLint64</code> values instead of </code>GLuint64</code> for timeout.
    </p>

    <h3><a name="CLIENT_WAIT_SYNC">clientWaitSync</a></h3>
    <p>
        In the WebGL 2.0 API, WebGL implementations must enforce a short maximum timeout on calls to clientWaitSync in
        order to avoid blocking execution of the main thread for excessive periods of time. This timeout may be queried
        by calling <code>getParameter</code> with the argument <code>MAX_CLIENT_WAIT_TIMEOUT_WEBGL</code>.
    </p>
    <div class="note">
        The implementation-defined maximum timeout is not specified. It is acceptable for an implementation to enforce a
        zero maximum timeout.
    </div>

    <h3><a name="VERTEX_ATTRIBUTE_ALIASING">Vertex Attribute Aliasing</a></h3>
    <p>
        WebGL 2.0 API implementations must strictly follow GLSL ES 3.00.6 section 12.46, which
        specifies that any vertex attribute aliasing is disallowed. As stated in
        <a href="#refsGLES30">[GLES30]</a> p57, GLSL ES 1.00 shaders may still alias, as allowed by
        the WebGL 1.0 spec section <a href="../1.0/index.html#ATTRIBUTE_ALIASING">Attribute
        aliasing</a>.
    </p>

    <h3><a name="NO_PRIMITIVE_RESTART_FIXED_INDEX">PRIMITIVE_RESTART_FIXED_INDEX is always enabled</a></h3>

    <p>
        The <code>PRIMITIVE_RESTART_FIXED_INDEX</code> context state, controlled
        with <code>Enable</code>/<code>Disable</code> in OpenGL ES 3.0, is not supported in WebGL
        2.0. Instead, WebGL 2.0 behaves as though this state were always enabled. <em>This is a
        compatibility difference compared to WebGL 1.0.</em>
    </p>
    <p>
        When <code>drawElements</code>, <code>drawElementsInstanced</code>,
        or <code>drawRangeElements</code> processes an index, if the index's value is the maximum
        for the data type (255 for <code>UNSIGNED_BYTE</code> indices, 65535
        for <code>UNSIGNED_SHORT</code>, or 4294967295 for <code>UNSIGNED_INT</code>), then the
        vertex is not processed normally. Instead, it is as if the drawing command ended with the
        immediately preceding vertex, and another drawing command is immediately started with the
        same parameters, but only transferring the immediately following index through the end of
        the originally specified indices.
    </p>
    <div class="note rationale">
        This compatibility difference was introduced in order to avoid performance pitfalls in
        Direct3D based WebGL implementations. Applications and content creation tools can be
        adjusted to avoid using the maximum vertex index if the primitive restart behavior is not
        desired.
    </div>

    <h3>No texture swizzles</h3>

    <p>
        OpenGL ES 3.0 introduces new state on texture objects allowing a four-channel swizzle
        operation to be specified against the texture. The swizzle is applied to every texture
        lookup performed within any shader referencing that texture. These texture swizzles are
        not supported in WebGL 2.0. <code>TEXTURE_SWIZZLE_*</code> enum values are removed from
        the WebGL 2.0 API.
    </p>

    <div class="note rationale">
        Texture swizzles can not be implemented in a performant manner on Direct3D based WebGL
        implementations. Applications relying on this functionality would run significantly more
        slowly on those implementations. Applications are still able to swizzle results of texture
        fetches in shaders and swizzle texture data before uploading without this interface.
    </div>

    <h3>Queries should fail on a program that failed to link</h3>

    <p>
        OpenGL ES 3.0 allows applications to enumerate and query properties of
        active variables and interface blocks of a specified program even if
        that program failed to link <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.11.3">OpenGL ES 3.0.4 &sect;2.11.3</a>)</span>.
        In WebGL, these commands will always generate an INVALID_OPERATION error
        on a program that failed to link, and no information is returned.
    </p>

    <div class="note rationale">
        The returned information in OpenGL ES 3.0 is implementation dependent and may be incomplete.
        The error condition is added to ensure consistent behavior across all platforms.
    </div>

    <h3>Color values from a fragment shader must match the color buffer format</h3>

    <p>
        Color values written by a fragment shader may be floating-point, signed integer, or unsigned
        integer. If the values written by the fragment shader do not match the format(s) of the
        corresponding color buffer(s), the result is undefined in OpenGL ES 3.0  <span class="gl-spec">(<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.9.2">OpenGL ES 3.0.4 &sect;3.9.2</a>)</span>. In WebGL, generates
        an <code>INVALID_OPERATION</code> error in the corresponding draw call, including
        <code>drawArrays</code>, <code>drawElements</code>, <code>drawArraysInstanced
        </code>, <code>drawElementsInstanced </code>, and <code>drawRangeElements</code>.
    </p>
    <p>
        If the color buffer has a normalized fixed-point format, floating-point color
        values are converted to match the format; generates no error in such situation.
    </p>

    <h3>A sampler type must match the internal texture format</h3>

    <p>
        Texture lookup functions return values as floating point, unsigned integer or signed integer,
        depending on the sampler type passed to the lookup function. If the wrong sampler type is
        used for texture access, i.e., the sampler type does not match the texture internal format,
        the returned values are undefined in OpenGL ES Shading Language 3.00.6
        <span class="gl-spec">(<a href="https://www.khronos.org/registry/gles/specs/3.0/GLSL_ES_Specification_3.00.pdf#nameddest=section-8.8">OpenGL ES Shading Language 3.00.6 &sect;8.8</a>)</span>.
        In WebGL, generates an <code>INVALID_OPERATION</code> error in the corresponding draw call,
        including <code>drawArrays</code>, <code>drawElements</code>, <code>drawArraysInstanced</code>,
        <code>drawElementsInstanced </code>, and <code>drawRangeElements</code>.
    </p>
    <p>
        If the sampler type is floating point and the internal texture format is
        normalized integer, it is considered as a match and the returned values are converted to
        floating point in the range [0, 1].
    </p>

    <h3>Queries' results must not be made available in the current frame</h3>

    <p>
        In OpenGL ES 3.0, if the appropriate primitives (e.g. <code>glFinish()</code> or another
        synchronous API) are called, a query's result may be made available in the same frame it was
        issued. In WebGL, in order to improve application portability, a query's result must never
        be made available to the application in the same frame the query was issued. See the
        specification of <a href="#GET_QUERY_PARAMETER">getQueryParameter</a> for discussion and
        rationale.
    </p>

    <h3>GLSL ES 3.00 #extension directive location</h3>

    <p>
        The WebGL 1.0 specification section <a href="../1.0/index.html#EXTENSION_DIRECTIVE_LOCATION">
        GLSL ES #extension directive location</a> only applies to OpenGL ES Shading Language 1.00
        shaders. It does not apply to shaders that are written in OpenGL ES Shading Language 3.00.
        In shaders written in OpenGL ES Shading Language 3.00, <code>#extension</code> directives
        must occur before non-preprocessor tokens regardless of what is written in the extension
        specification.
    </p>

    <div class="note rationale">
        This is done to make WebGL 2.0 to follow the written GLSL ES 3.00 specification more
        closely. Enforcing the restriction more strictly than native GLES drivers makes the behavior
        well-defined.
    </div>

    <h3>Only <code>std140</code> layout supported in uniform blocks</h3>

    <p>
        The GLSL ES 3.00 specification supports the <code>shared</code>, <code>packed</code>,
        and <code>std140</code> layout qualifiers for uniform blocks, defining how variables are
        laid out in uniform buffers' storage. Of these, the WebGL 2.0 specification supports only
        the <code>std140</code> layout, which is defined
        in <a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.12">OpenGL
        ES 3.0.4 &sect;2.12 "Vertex Shaders"</a>, subsection "Standard Uniform Block
        Layout". Shaders attempting to use the <code>shared</code> or <code>packed</code> layout
        qualifiers will fail either the compilation or linking stages.
    </p>

    <p>
        The initial state of compilation is as if the following were declared:
    </p>

    <p><code>
        layout(std140) uniform;
    </code></p>

    <div class="note rationale">
        This restriction is enforced to improve portability by avoiding exposing uniform block
        layouts that are specific to one vendor's GPUs.
    </div>

    <h3>Disallowed variants of GLSL ES 3.00 operators</h3>

    <p>
        In the WebGL 2.0 API, the following shading language constructs are not allowed and
        attempting to use them must result in a compile error:
    </p>

    <ul>
        <li>Ternary operator applied to void, arrays, or structs containing arrays</li>
        <li>Sequence operator applied to void, arrays, or structs containing arrays</li>
    </ul>

    <div class="note rationale">
        This restriction ensures easy portability across OpenGL ES 3.0 supporting devices.
    </div>

    <h3><a name="INCOMPLETE_DIMENSIONS">checkFramebufferStatus may return FRAMEBUFFER_INCOMPLETE_DIMENSIONS</a></h3>

    <p>All attached images much have the same width and height; otherwise, <code>checkFramebufferStatus</code> returns <code>FRAMEBUFFER_INCOMPLETE_DIMENSIONS</code>.</p>

    <div class="note rationale">In OpenGL ES 3, attached images for a framebuffer need not to have the same width and height to be framebuffer complete, and <code>FRAMEBUFFER_INCOMPLETE_DIMENSIONS</code> is not one of the valid return values for <code>checkFramebufferStatus</code>. However, in Direct3D 11, on top of which OpenGL ES 3 behavior is emulated in Windows, all render targets must have the same size in all dimensions (see <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff476464(v=vs.85).aspx">msdn manual page</a>). Emulation of the ES3 semantic on top of DirectX 11 will be inefficient. In order to have consistent WebGL 2.0 behaviors across platforms, it is reasonable to keep the OpenGL ES 2 / WebGL 1.0 restriction for WebGL 2.0 that all attached images must have the same width and height.</div>

    <h3>Uniform block matching</h3>

    <p>
        In the WebGL 2.0 API, layout qualifiers <code>row_major</code> and <code>column_major</code>
        are required to match in matched uniform blocks even when they are applied exclusively on
        non-matrix variables.
    </p>

    <div class="note rationale">
        This uniform block matching rule is known to be inconsistent across OpenGL ES 3.0
        implementations.
    </div>

    <h3>Framebuffer contents after invalidation</h3>
    <p>
        In OpenGL ES 3.0, after calling <code>invalidateFramebuffer</code> or <code>invalidateSubFramebuffer</code>,
        the affected region's contents become effectively undefined. In WebGL 2.0, it is required for the contents
        to either stay unchanged or become all 0.
    </p>

    <div class="note">
        It is acceptable for WebGL 2.0 implementations to make <code>invalidateFramebuffer</code> or
        <code>invalidateSubFramebuffer</code> a no-op.
    </div>

    <h3>No ArrayBufferView matching texture type FLOAT_32_UNSIGNED_INT_24_8_REV</h3>
    <p>
        In <code>texImage2D</code> and <code>texImage3D</code> with ArrayBufferView, if
        <em>type</em> is <code>FLOAT_32_UNSIGNED_INT_24_8_REV</code> and <em>srcData</em> is not
        <code>null</code>, generates an <code>INVALID_OPERATION</code>.
    </p>

    <p>
        In <code>texSubImage2D</code> and <code>texSubImage3D</code> with ArrayBufferView, if <em>type</em> is
        <code>FLOAT_32_UNSIGNED_INT_24_8_REV</code>, generates an <code>INVALID_ENUM</code>.
    </p>


    <h3><a name="ATTRIBUTE_TYPE_MATCH">VertexAttrib function must match shader attribute type</a></h3>

    <p>
        If any of the following situations are true, attempting to draw with <code>drawArrays</code>,
        <code>drawElements</code>, <code>drawRangeElements</code> or their instanced variants generates an
        <code>INVALID_OPERATION</code> error:
    </p>

    <ul>
      <li>
        <code>vertexAttribPointer</code>, <code>vertexAttrib{1234}f</code>, or <code>vertexAttrib{1234}fv
        </code> is used and the base type of the shader attribute at slot <code>index</code> is not
        floating-point (e.g. is signed or unsigned integer);
      </li>
      <li>
        <code>vertexAttribIPointer</code> is used with <code>type</code> <code>UNSIGNED_BYTE</code>,
        <code>UNSIGNED_SHORT</code> or <code>UNSIGNED_INT</code>, or <code>vertexAttribI4ui</code> or
        <code>vertexAttribI4uiv</code> is used, and the base type of the shader attribute at slot
        <code>index</code> is not unsigned integer (e.g. is floating-point or signed integer);
      </li>
      <li>
        <code>vertexAttribIPointer</code> is used with <code>type</code> <code>BYTE</code>,
        <code>SHORT</code> or <code>INT</code>, or <code>vertexAttribI4i</code> or <code>
        vertexAttribI4iv</code> is used, and the base type of the shader attribute at slot
        <code>index</code> is not signed integer (e.g. is floating-point or unsigned integer).
      </li>
    </ul>

    <div class="note">
        This undefined behavior is in the OpenGL ES 3.0 specification section 2.8 <span class="gl-spec">
        (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.8">
        OpenGL ES 3.0.4 &sect;2.8</a>)</span>.
    </div>

    <h3><a name="TRANSFORM_FEEDBACK_NOT_WRITTEN">Transform feedback primitive capture</a></h3>

    <p>
        If any output variable is specified to be streamed to a buffer object but not actually
        written by a vertex shader, the value is set to 0.
    </p>

    <div class="note">
        This undefined behavior is in the OpenGL ES 3.0 specification section 2.15.2 <span class="gl-spec">
        (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-2.15.2">
        OpenGL ES 3.0.4 &sect;2.15.2</a>)</span>.
    </div>

    <h3>gl_FragDepth</h3>

    <p>
        If a fragment shader statically assigns a value to <code>gl_FragDepth</code>, for any fragment
        where statements assigning a value to gl_FragDepth are not executed, the value 0 is used.
    </p>

    <div class="note">
        This undefined behavior is in the OpenGL ES 3.0 specification section 3.9.2 <span class="gl-spec">
        (<a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf#nameddest=section-3.9.2">
        OpenGL ES 3.0.4 &sect;3.9.2</a>).
    </div>

    <h3><a name="FRAMEBUFFER_COLOR_ATTACHMENTS">Framebuffer color attachments</a></h3>

    <p>
        If an image is attached to more than one color attachment point in a framebuffer,
        <code>checkFramebufferStatus</code> returns <code>FRAMEBUFFER_UNSUPPORTED</code>.
        An image can be an individual mip level, an array slice (from either 2D array
        or cube map textures), or a 3D texture slice.
    </p>

    <div class="note rationale">
        This is a limitation of Direct3D 11, on top of which OpenGL ES 3 behavior is emulated on Windows.
        (see <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff476464.aspx">msdn manual
        page</a>). In order to have consistent WebGL 2.0 behavior across platforms, it is reasonable to add
        this limitation in WebGL 2.0 for all platforms.
    </div>

    <h3><a name="DOM_UPLOAD_UNPACK_PARAMS">Pixel store parameters for uploads from TexImageSource</a></h3>

    <p><code>UNPACK_ALIGNMENT</code> and <code>UNPACK_ROW_LENGTH</code> are ignored.
       <code>UNPACK_ALIGNMENT</code> is specified in bytes, and is implicit and
       implementation-dependent for TexImageSource objects. <code>UNPACK_ROW_LENGTH</code> is
       currently unused.</p>
    <p>Subrect selection is possible using <code>UNPACK_</code> params.
       <code>UNPACK_SKIP_PIXELS</code> and <code>UNPACK_SKIP_ROWS</code> determine the origin of the
       subrect, with the <code>width</code> and <code>height</code> arguments determining the size of the subrect.</p>
    <p>For 3D textures, the <code>width</code>, <code>height</code>, and <code>depth</code>
       arguments specify a rectangular region of a texel array to unpack to.
       <code>UNPACK_SKIP_IMAGES</code> and <code>UNPACK_IMAGE_HEIGHT</code> allow selection of
       multiple slices from the 2D source.  <code>UNPACK_IMAGE_HEIGHT</code> determines the stride,
       in rows, between two slices. For example, a <code>TexImageSource</code> 30 pixels tall may
       have the top 10 and bottom 10 rows uploaded into two slices of a 3D texture by uploading with
       <code>height</code> equal to 10, <code>UNPACK_IMAGE_HEIGHT</code> set to 20, and
       <code>depth</code> equal to 2.  If <code>UNPACK_IMAGE_HEIGHT</code> is 0, the stride, in
       rows, between two slices defaults to <code>height</code>.</p>
    <p>For an <code>HTMLImageElement</code> 20 pixels wide, passing <code>width = 10</code> for
       texture upload will cause only the left half of the image to be selected, thus uploaded. The
       resulting texture will have a width of 10. If, additionally in this example,
       <code>UNPACK_SKIP_PIXELS</code> is set to 10, only the right half of the image is selected
       for unpack.</p>
    <p>Also, <code>UNPACK_SKIP_IMAGES</code> applies only to 3D entrypoints, not to 2D entrypoints.</p>
    <img src="six_color_32x48.png"></image>
    <p>Looking at another example, the above 32x48 image of six colors, each of size 16x16, is uploaded to
      a 3D texture of  <code>width = 2</code>, <code>height = 1</code>, and <code>depth = 3</code>.
      <ul>
        <li>If <code>UNPACK_SKIP_PIXELS</code> is 0, <code>UNPACK_SKIP_ROWS</code> is 0, and <code>UNPACK_IMAGE_HEIGHT</code>
            is 0, the entire texel array is set to red.</li>
        <li>If <code>UNPACK_SKIP_PIXELS</code> is 16, <code>UNPACK_SKIP_ROWS</code> is 16, and <code>UNPACK_IMAGE_HEIGHT</code>
            is 0, the entire texel array is set to yellow.</li>
        <li>If <code>UNPACK_SKIP_PIXELS</code> is 0, <code>UNPACK_SKIP_ROWS</code> is 0, and <code>UNPACK_IMAGE_HEIGHT</code>
            is 16, the first slice of the texel array is red, the second slice is blue, and the third slice is purple.</li>
        <li>If <code>UNPACK_SKIP_PIXELS</code> is 16, <code>UNPACK_SKIP_ROWS</code> is 0, and <code>UNPACK_IMAGE_HEIGHT</code>
            is 16, the first slice of the texel array is green, the second slice is yellow, and the third slice is pink.</li>
      </ul>
    </p>

    <h3><a name="PIXEL_STORE_PARAM_CONSTRAINTS">Pixel store parameter constraints</a></h3>

    <p>
        Define:
        <ul>
          <li>DataStoreWidth := <code>ROW_LENGTH</code> ? <code>ROW_LENGTH</code> : <em>width</em></li>
          <li>DataStoreHeight := <code>IMAGE_HEIGHT</code> ? <code>IMAGE_HEIGHT</code> : <em>height</em></li>
        </ul>
    </p>

    <p>
        If <code>PACK_SKIP_PIXELS</code> + <em>width</em> > DataStoreWidth, <code>readPixels</code>
        generates an <code>INVALID_OPERATION</code> error.
    </p>

    <p>
        If <code>UNPACK_SKIP_PIXELS</code> + <em>width</em> > DataStoreWidth,
        <code>texImage2D</code> and <code>texSubImage2D</code> generate an
        <code>INVALID_OPERATION</code> error. This does not apply to <code>texImage2D</code> if no
        <code>PIXEL_UNPACK_BUFFER</code> is bound and <em>srcData</em> is null.
    </p>

    <p>
        If <code>UNPACK_SKIP_PIXELS</code> + <em>width</em> > DataStoreWidth or
        <code>UNPACK_SKIP_ROWS</code> + <em>height</em> >  DataStoreHeight, <code>texImage3D</code>
        and <code>texSubImage3D</code> generate an <code>INVALID_OPERATION</code> error. This does
        not apply to <code>texImage3D</code> if no <code>PIXEL_UNPACK_BUFFER</code> is bound and
        <em>srcData</em> is null.
    </p>

    <div class="note rationale">
      <p>These constraints normalize the use of these parameters to specify a sub region where
         pixels are stored. For example, in <code>readPixels</code> cases, if we want to store
         pixels to a sub area of the entire data store, we can use <code>PACK_ROW_LENGTH</code> to
         specify the data store width, and <code>PACK_SKIP_PIXELS</code>,
         <code>PACK_SKIP_ROWS</code>, <em>width</em> and <em>height</em> to specify the subarea's
         xoffset, yoffset, width, and height</code>.

      <p>These contraints also forbid row and image overlap, where the situations are not tested in
         the OpenGL ES 3.0 DEQP test suites, and many drivers behave incorrectly. They also forbid
         skipping random pixels or rows, but that can be achieved by adjusting the data store offset
         accordingly.

      <p>Further, for uploads from <code>TexImageSource</code>, implied
         <code>UNPACK_ROW_LENGTH</code> and <code>UNPACK_ALIGNMENT</code> are not strictly defined.
         These restrictions ensure consistent and efficient behavior regardless of implied
         <code>UNPACK_</code> params.
    </div>

    <p>
        If <code>UNPACK_FLIP_Y_WEBGL</code> or <code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code> is set to true,
        <code>texImage2D</code> and <code>texSubImage2D</code> generate an <code>INVALID_OPERATION</code> error
        if they upload data from a <code>PIXEL_UNPACK_BUFFER</code>.
    </p>

    <p>
        If <code>UNPACK_FLIP_Y_WEBGL</code> or <code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code> is set to true,
        <code>texImage3D</code> and <code>texSubImage3D</code> generate an <code>INVALID_OPERATION</code> error
        if they upload data from a <code>PIXEL_UNPACK_BUFFER</code> or a non-null client side
        <code>ArrayBufferView</code>.
    </p>

    <h3><a name="NO_ETC2_EAC">No ETC2 and EAC compressed texture formats</a></h3>
    <p>OpenGL ES 3.0 requires support for the following ETC2 and EAC compressed texture formats:
       COMPRESSED_R11_EAC, COMPRESSED_SIGNED_R11_EAC, COMPRESSED_RG11_EAC,
       COMPRESSED_SIGNED_RG11_EAC, COMPRESSED_RGB8_ETC2, COMPRESSED_SRGB8_ETC2,
       COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
       COMPRESSED_RGBA8_ETC2_EAC, and COMPRESSED_SRGB8_ALPHA8_ETC2_EAC.

    <p>These texture formats are not supported by default in WebGL 2.0.

    <div class="note rationale">
        <p>These formats are not natively supported by most desktop GPU hardware.
           As such, supporting these formats requires software decompression in either the
           WebGL implementation or the underlying driver. This results in a drastic
           increase in video memory usage, causing performance losses which are
           invisible to the WebGL application.
        <p>On hardware which supports the ETC2 and EAC compressed texture formats natively
           (e.g. mobile OpenGL ES 3.0+ hardware), they may be exposed via the extension
           <code>WEBGL_compressed_texture_etc</code>.
    </div>

    <h3>The value of UNIFORM_BUFFER_OFFSET_ALIGNMENT must be divisible by 4</h3>

    <p>The value of <code>UNIFORM_BUFFER_OFFSET_ALIGNMENT</code>, as given in basic machine units, must be divisible by 4.</p>

    <div class="note rationale">
        If the value of UNIFORM_BUFFER_OFFSET_ALIGNMENT was not divisible by 4, it would make it impractical to upload ArrayBuffers to uniform buffers which are bound with BindBufferRange.
    </div>

    <h3>Sync objects' results must not be made available in the current frame</h3>

    <p>
        In OpenGL ES 3.0, if the appropriate primitives (e.g. <code>glFinish()</code> or another
        synchronous API) are called, a sync object may be signaled in the same frame it was
        issued. In WebGL, in order to improve application portability, a sync object must never
        transition to the signaled state in the same frame the sync was issued. See the
        specification of <a href="#GET_SYNC_PARAMETER">getSyncParameter</a>
        and <a href="#CLIENT_WAIT_SYNC">clientWaitSync</a> for discussion and rationale.
    </p>

<!-- ======================================================================================================= -->

    <h2>References</h2>

    <dl>
        <dt id="refsWEBGL10">[WEBGL10]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/webgl/specs/latest/1.0/">
            WebGL Specification 1.0.4 Editor's Draft</a></cite>,
            Dean Jackson, Jeff Gilbert.
        </dd>
        <dt id="refsCANVAS">[CANVAS]</dt>
        <dd><cite><a href="http://www.w3.org/TR/html5/scripting-1.html#the-canvas-element">
            HTML5: The Canvas Element</a></cite>,
            World Wide Web Consortium (W3C).
        </dd>
        <dt id="refsCANVASCONTEXTS">[CANVASCONTEXTS]</dt>
        <dd><cite><a href="http://wiki.whatwg.org/wiki/CanvasContexts">
            Canvas Context Registry</a></cite>,
            WHATWG.
        </dd>
        <dt id="refsGLES30">[GLES30]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.4.pdf">
            OpenGL&reg; ES Version 3.0.4</a></cite>,
            B. Lipchak 2014.
        </dd>
        <dt id="refsGLES30GLSL">[GLES30GLSL]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/gles/specs/3.0/GLSL_ES_Specification_3.00.pdf">
            The OpenGL&reg; ES Shading Language Version 3.00.6</a></cite>,
            R. Simpson, January 2016.
        </dd>
        <dt id="refsREGISTRY">[REGISTRY]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/webgl/extensions/">
            WebGL Extension Registry</a></cite>
        </dd>
        <dt id="refsRFC2119">[RFC2119]</dt>
        <dd><cite><a href="http://www.ietf.org/rfc/rfc2119.txt">
            Key words for use in RFCs to Indicate Requirement Levels</a></cite>,
            S. Bradner. IETF, March 1997.
        </dd>
        <dt id="refsWEBIDL">[WEBIDL]</dt>
        <dd><cite><a href="https://heycam.github.io/webidl/">
            Web IDL: W3C Editor’s Draft</a></cite>,
            C. McCormack, B. Zbarsky, T. Langel.
        </dd>
    </dl>

</body>
</html>
