// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CONTENT_COMMON_BLUETOOTH_WEB_BLUETOOTH_DEVICE_ID_H_
#define CONTENT_COMMON_BLUETOOTH_WEB_BLUETOOTH_DEVICE_ID_H_

#include <string>

#include "content/common/content_export.h"

namespace content {

// Used to uniquely identify a Bluetooth Device for an Origin.
// A WebBluetoothDeviceId is generated by base64-encoding a 128bit
// string.
class CONTENT_EXPORT WebBluetoothDeviceId {
 public:
  // Default constructor that creates an invalid id. We implement it so that
  // instances of this class in a container, e.g. std::unordered_map, can be
  // accessed through the [] operator. Trying to call any function of the
  // resulting object will DCHECK-fail.
  WebBluetoothDeviceId();

  // DCHECKS that |device_id| is valid.
  explicit WebBluetoothDeviceId(std::string device_id);
  ~WebBluetoothDeviceId();

  // Returns the string that represents this WebBluetoothDeviceId.
  const std::string& str() const;

  // The returned WebBluetoothDeviceId is generated by creating a random 128bit
  // string and base64-encoding it.
  static WebBluetoothDeviceId Create();

  // Returns true if base64-decoding |device_id| results in a 128bit string.
  static bool IsValid(const std::string& device_id);

  bool operator==(const WebBluetoothDeviceId& device_id) const;
  bool operator!=(const WebBluetoothDeviceId& device_id) const;

 private:
  std::string device_id_;
};

// This is required by gtest to print a readable output on test failures.
CONTENT_EXPORT std::ostream& operator<<(std::ostream& out,
                                        const WebBluetoothDeviceId& device_id);

struct WebBluetoothDeviceIdHash {
  size_t operator()(const WebBluetoothDeviceId& device_id) const {
    return std::hash<std::string>()(device_id.str());
  }
};

}  // namespace content

#endif  // CONTENT_COMMON_BLUETOOTH_WEB_BLUETOOTH_DEVICE_ID_H_
