{{+bindTo:partials.standard_nacl_api}}
<h1>pp::VpnProvider Class Reference</h1>
<div id="doxygen-ref">
{{- dummy div to appease doxygen -}}
  <div>
<!-- Generated by Doxygen 1.7.6.1 -->



</div>
<!--header-->
<div class="contents">
<!-- doxytag: class="pp::VpnProvider" --><!-- doxytag: inherits="pp::Resource" --><div class="dynheader">
Inheritance diagram for pp::VpnProvider:</div>
<div class="dyncontent">
<div class="center"><img src="classpp_1_1_vpn_provider__inherit__graph.png" border="0" usemap="#pp_1_1_vpn_provider_inherit__map" alt="Inheritance graph" /></div>
<map name="pp_1_1_vpn_provider_inherit__map" id="pp_1_1_vpn_provider_inherit__map">
<area shape="rect" id="node2" href="classpp_1_1_resource.html" title="A reference counted module resource." alt="" coords="15,5,119,32"></area></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<p><a href="classpp_1_1_vpn_provider-members.html">List of all members.</a></p>
<h2>
Public Member Functions</h2><table class="memberdecls">

<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_vpn_provider.html#a5d44d34828cce02849b2ade71de054f6">VpnProvider</a> (const <a class="el" href="classpp_1_1_instance_handle.html">InstanceHandle</a> &amp;instance)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_vpn_provider.html#a0ae82ce542bed9af72da27fb4c94ec42">~VpnProvider</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_vpn_provider.html#a90d17a19973f48a31ea933325e0b61af">Bind</a> (const <a class="el" href="classpp_1_1_var.html">Var</a> &amp;configuration_id, const <a class="el" href="classpp_1_1_var.html">Var</a> &amp;configuration_name, const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;callback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_vpn_provider.html#ae692340a675bcd27c756e98779efe615">SendPacket</a> (const <a class="el" href="classpp_1_1_var.html">Var</a> &amp;packet, const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;callback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_vpn_provider.html#a745f12bb3d3eb9bf7f29892a717caefb">ReceivePacket</a> (const <a class="el" href="classpp_1_1_completion_callback_with_output.html">CompletionCallbackWithOutput</a>&lt; <a class="el" href="classpp_1_1_var.html">Var</a> &gt; &amp;callback)</td></tr>
</table><h2>
Static Public Member Functions</h2><table class="memberdecls">
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_vpn_provider.html#a0a6b1fd0a843997fafe1bf5bed85b3b9">IsAvailable</a> ()</td></tr>
</table>
<hr /><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The <code><a class="el" href="classpp_1_1_vpn_provider.html" title="The VpnProvider class enhances the chrome.vpnProvider JavaScript API by providing a high performance ...">VpnProvider</a></code> class enhances the <code>chrome.vpnProvider</code> JavaScript API by providing a high performance path for packet handling. </p>
<p>Permissions: Apps permission <code>vpnProvider</code> is required for <code><a class="el" href="classpp_1_1_vpn_provider.html#a90d17a19973f48a31ea933325e0b61af" title="Binds to an existing configuration created from JavaScript by chrome.vpnProvider.createConfig.">VpnProvider.Bind()</a></code>.</p>
<p>Typical usage:</p>
<ul>
<li>Create a <code><a class="el" href="classpp_1_1_vpn_provider.html" title="The VpnProvider class enhances the chrome.vpnProvider JavaScript API by providing a high performance ...">VpnProvider</a></code> instance.</li>
<li>Register the callback for <code><a class="el" href="classpp_1_1_vpn_provider.html#a745f12bb3d3eb9bf7f29892a717caefb" title="Receives an IP packet from the tunnel for the VPN session.">VpnProvider.ReceivePacket()</a></code>.</li>
<li>In the extension follow the usual workflow for configuring a VPN connection via the <code>chrome.vpnProvider</code> API until the step for notifying the connection state as "connected".</li>
<li>Bind to the previously created connection using <code><a class="el" href="classpp_1_1_vpn_provider.html#a90d17a19973f48a31ea933325e0b61af" title="Binds to an existing configuration created from JavaScript by chrome.vpnProvider.createConfig.">VpnProvider.Bind()</a></code>.</li>
<li>Notify the connection state as "connected" from JavaScript using <code>chrome.vpnProvider.notifyConnectionStateChanged</code>.</li>
<li>When the steps above are completed without errors, a virtual tunnel is created to the network stack of Chrome OS. IP packets can be sent through the tunnel using <code><a class="el" href="classpp_1_1_vpn_provider.html#ae692340a675bcd27c756e98779efe615" title="Sends an IP packet through the tunnel created for the VPN session.">VpnProvider.SendPacket()</a></code> and any packets originating on the Chrome OS device will be received using the callback registered for <code><a class="el" href="classpp_1_1_vpn_provider.html#a745f12bb3d3eb9bf7f29892a717caefb" title="Receives an IP packet from the tunnel for the VPN session.">VpnProvider.ReceivePacket()</a></code>.</li>
<li>When the user disconnects from the VPN configuration or there is an error the extension will be notfied via <code>chrome.vpnProvider.onPlatformMessage</code>. </li>
</ul>
</div><hr /><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5d44d34828cce02849b2ade71de054f6"></a><!-- doxytag: member="pp::VpnProvider::VpnProvider" ref="a5d44d34828cce02849b2ade71de054f6" args="(const InstanceHandle &amp;instance)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_vpn_provider.html#a5d44d34828cce02849b2ade71de054f6">pp::VpnProvider::VpnProvider</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_instance_handle.html">InstanceHandle</a> &amp;&#160;</td>
<td class="paramname"><em>instance</em></td><td>)</td>
<td><code> [explicit]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Constructs a <a class="el" href="classpp_1_1_vpn_provider.html" title="The VpnProvider class enhances the chrome.vpnProvider JavaScript API by providing a high performance ...">VpnProvider</a> object. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>The instance with which this resource will be associated. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a0ae82ce542bed9af72da27fb4c94ec42"></a><!-- doxytag: member="pp::VpnProvider::~VpnProvider" ref="a0ae82ce542bed9af72da27fb4c94ec42" args="()" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">virtual <a class="el" href="classpp_1_1_vpn_provider.html#a0ae82ce542bed9af72da27fb4c94ec42">pp::VpnProvider::~VpnProvider</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td><code> [virtual]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Destructs a <a class="el" href="classpp_1_1_vpn_provider.html" title="The VpnProvider class enhances the chrome.vpnProvider JavaScript API by providing a high performance ...">VpnProvider</a> object. </p>
</div>
</div>
<hr /><h2>Member Function Documentation</h2>
<a class="anchor" id="a90d17a19973f48a31ea933325e0b61af"></a><!-- doxytag: member="pp::VpnProvider::Bind" ref="a90d17a19973f48a31ea933325e0b61af" args="(const Var &amp;configuration_id, const Var &amp;configuration_name, const CompletionCallback &amp;callback)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_vpn_provider.html#a90d17a19973f48a31ea933325e0b61af">pp::VpnProvider::Bind</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_var.html">Var</a> &amp;&#160;</td>
<td class="paramname"><em>configuration_id</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classpp_1_1_var.html">Var</a> &amp;&#160;</td>
<td class="paramname"><em>configuration_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;&#160;</td>
<td class="paramname"><em>callback</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Binds to an existing configuration created from JavaScript by <code>chrome.vpnProvider.createConfig</code>. </p>
<p>All packets will be routed via <code>SendPacket</code> and <code>ReceivePacket</code>. The user should register the callback for <code>ReceivePacket</code> before calling <code><a class="el" href="classpp_1_1_vpn_provider.html#a90d17a19973f48a31ea933325e0b61af" title="Binds to an existing configuration created from JavaScript by chrome.vpnProvider.createConfig.">Bind()</a></code>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">configuration_id</td><td>The configuration id from the callback of <code>chrome.vpnProvider.createConfig</code>. This <code><a class="el" href="classpp_1_1_var.html" title="A generic type used for passing data types between the module and the page.">Var</a></code> must be of string type.</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">configuration_name</td><td>The configuration name as defined by the user when calling <code>chrome.vpnProvider.createConfig</code>. This <code><a class="el" href="classpp_1_1_var.html" title="A generic type used for passing data types between the module and the page.">Var</a></code> must be of string type.</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> to be called on completion.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An int32_t containing an error code from <code>pp_errors.h</code>. Returns <code>PP_ERROR_INPROGRESS</code> if a previous call to <code><a class="el" href="classpp_1_1_vpn_provider.html#a90d17a19973f48a31ea933325e0b61af" title="Binds to an existing configuration created from JavaScript by chrome.vpnProvider.createConfig.">Bind()</a></code> has not completed. Returns <code>PP_ERROR_BADARGUMENT</code> if the <code><a class="el" href="classpp_1_1_var.html" title="A generic type used for passing data types between the module and the page.">Var</a></code> type of either <code>configuration_id</code> or <code>configuration_name</code> is not of string type. Returns <code>PP_ERROR_NOACCESS</code> if the caller does the have the required "vpnProvider" permission. Returns <code>PP_ERROR_FAILED</code> if <code>connection_id</code> and <code>connection_name</code> could not be matched with the existing connection, or if the plugin originates from a different extension than the one that created the connection. </dd></dl>
</div>
</div>
<a class="anchor" id="a0a6b1fd0a843997fafe1bf5bed85b3b9"></a><!-- doxytag: member="pp::VpnProvider::IsAvailable" ref="a0a6b1fd0a843997fafe1bf5bed85b3b9" args="()" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">static bool <a class="el" href="classpp_1_1_vpn_provider.html#a0a6b1fd0a843997fafe1bf5bed85b3b9">pp::VpnProvider::IsAvailable</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td><code> [static]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Static function for determining whether the browser supports the <code><a class="el" href="classpp_1_1_vpn_provider.html" title="The VpnProvider class enhances the chrome.vpnProvider JavaScript API by providing a high performance ...">VpnProvider</a></code> interface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the interface is available, false otherwise. </dd></dl>
</div>
</div>
<a class="anchor" id="a745f12bb3d3eb9bf7f29892a717caefb"></a><!-- doxytag: member="pp::VpnProvider::ReceivePacket" ref="a745f12bb3d3eb9bf7f29892a717caefb" args="(const CompletionCallbackWithOutput&lt; Var &gt; &amp;callback)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_vpn_provider.html#a745f12bb3d3eb9bf7f29892a717caefb">pp::VpnProvider::ReceivePacket</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_completion_callback_with_output.html">CompletionCallbackWithOutput</a>&lt; <a class="el" href="classpp_1_1_var.html">Var</a> &gt; &amp;&#160;</td>
<td class="paramname"><em>callback</em></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Receives an IP packet from the tunnel for the VPN session. </p>
<p>This function only returns a single packet. That is, this function must be called at least N times to receive N packets, no matter the size of each packet. The callback should be registered before calling <code><a class="el" href="classpp_1_1_vpn_provider.html#a90d17a19973f48a31ea933325e0b61af" title="Binds to an existing configuration created from JavaScript by chrome.vpnProvider.createConfig.">Bind()</a></code>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A <code><a class="el" href="classpp_1_1_completion_callback_with_output.html" title="A CompletionCallbackWithOutput defines a completion callback that additionally stores a pointer to so...">CompletionCallbackWithOutput</a></code> to be called upon completion of ReceivePacket. It will be passed an ArrayBuffer type <code><a class="el" href="classpp_1_1_var.html" title="A generic type used for passing data types between the module and the page.">Var</a></code> containing an IP packet to be sent to the platform.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An int32_t containing an error code from <code>pp_errors.h</code>. Returns <code>PP_ERROR_INPROGRESS</code> if a previous call to <code><a class="el" href="classpp_1_1_vpn_provider.html#a745f12bb3d3eb9bf7f29892a717caefb" title="Receives an IP packet from the tunnel for the VPN session.">ReceivePacket()</a></code> has not completed. </dd></dl>
</div>
</div>
<a class="anchor" id="ae692340a675bcd27c756e98779efe615"></a><!-- doxytag: member="pp::VpnProvider::SendPacket" ref="ae692340a675bcd27c756e98779efe615" args="(const Var &amp;packet, const CompletionCallback &amp;callback)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_vpn_provider.html#ae692340a675bcd27c756e98779efe615">pp::VpnProvider::SendPacket</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_var.html">Var</a> &amp;&#160;</td>
<td class="paramname"><em>packet</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;&#160;</td>
<td class="paramname"><em>callback</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Sends an IP packet through the tunnel created for the VPN session. </p>
<p>This will succeed only when the VPN session is owned by the module and connection is bound.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>IP packet to be sent to the platform. The <code><a class="el" href="classpp_1_1_var.html" title="A generic type used for passing data types between the module and the page.">Var</a></code> must be of ArrayBuffer type.</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> to be called on completion.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An int32_t containing an error code from <code>pp_errors.h</code>. Returns <code>PP_ERROR_FAILED</code> if the connection is not bound. Returns <code>PP_ERROR_INPROGRESS</code> if a previous call to <code><a class="el" href="classpp_1_1_vpn_provider.html#ae692340a675bcd27c756e98779efe615" title="Sends an IP packet through the tunnel created for the VPN session.">SendPacket()</a></code> has not completed. Returns <code>PP_ERROR_BADARGUMENT</code> if the <code><a class="el" href="classpp_1_1_var.html" title="A generic type used for passing data types between the module and the page.">Var</a></code> type of <code>packet</code> is not of ArrayBuffer type. </dd></dl>
</div>
</div>
<hr />The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="vpn__provider_8h.html">vpn_provider.h</a></li>
</ul>
</div><!-- contents -->
</div>
{{/partials.standard_nacl_api}}
